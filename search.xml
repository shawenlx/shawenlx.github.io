<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[『Hexo』使用Hexo搭建GitHub博客]]></title>
      <url>%2F2016%2F12%2F01%2F%E3%80%8EHexo%E3%80%8F%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[『Hexo』使用Hexo搭建GitHub博客 前言：​ 谈起这个博客的由来，真的挺不容易的。一年前兴奋地买了域名，后来因为很多东西都不具备实现这个模版博客的能力，遂搁置了域名，选择了简书。有点笨，这一次也折腾了两三个晚上，总算把它搭建起来了。 环境准备 git搭建 ：git教程 node.js : node.js download git主要用于将代码同步到GitHub平台，node.js主要用到了npm这个包管理器，方便我们快速搭建Hexo环境。 个人的主机环境为：MacOS 注册Github 我们的主要目的就是把本地的静态网站托管到GitHub这个平台上。 Tips: 我遇到的一个坑就是，我用的是QQ邮箱注册，GitHub验证邮件被拦截了，貌似163邮箱也会拦截。一定要验证邮箱，否则即使你博客搭建好了，托管到GitHub上面，也会一直404无法打开。 Quick Start 安装Hexo 1sudo npm install hexo-cli -g Hexo官方文档：Hexo 利用Hexo初始化一个博客文件夹 1hexo init [文件夹] npm install 命令用来安装模块到node_modules目录。 12cd [文件夹] //进入到博客文件夹npm install //利用npm install命令安装模块node_modules 关于npm的详细使用，参照文档，或者npm 模块安装机制简介。 至此，一个博客已经搭建好了，但是我们还没办法看到它。接下来就利用Hexo命令来启动我们的博客。 12hexo g //利用Hexo 生成静态页面hexo s //启动本地服务 你一定迫不及待想看看这个东西给你带来了什么样的惊喜。打开浏览器，http://localhost:4000，你就可以看到一个模版博客已经出现在你面前了，虽然这不是你最终想要的，不过也算是让我们眼前一亮。 命令倒是执行了几个了，但是我们不知道它到底做了些什么。先来看看吧。 1ls //查看文件目录， 当然一些隐藏文件无法查看， 没关系，ls -al即可。 暂时忽略其他文件是干什么的，先看看 _config.yml，这是我博客的设置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Shawenlx #博客标题subtitle: #副标题description: I love code and share. #个人描述author: Liuxi #作者名language: en #站点语言，如果是中文，把en替换成zh-CNtimezone: #同步时区# URLurl: /root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directory 文件目录对应生成的文件夹目录source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: #代码高亮 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map: categoriestag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination ## Set per_page to 0 to disable pagination 设置分页per_page: 10pagination_dir: page# Extensionstheme: next #主题模版，搜索 ./themes 文件夹下的主题，此处我用的NexT模版# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/shawenlx/shawenlx.github.io.git branch: master Tips: 当我们着手修改这个文件的时候，字段名以及:后面，切记一定要加一个空格！我一开始也遇到这个问题，执行hexo g命令的时候，就会报错提示我_config.yml文件无法解析。 将博客托管到Github平台 创建一个GitHub仓库，new repository 在 Repository name 栏中，输入 your user name.github.io，譬如我的GitHub用户名是shawenlx，所以就建立工程名为：shawenlx.github.io 配置好本地的SSH Key。 拥有了个人的GitHub Pages后，再回到Hexo的_config.yml文件, 参照我的配置保存即可。 1234deploy: type: git repo: https://github.com/shawenlx/shawenlx.github.io.git branch: master 最后利用hexo命令，将博客推送到Github上。 12hexo clean #推送前，先清除下本地数据库，防止缓存导致上传不成功hexo d -g #利用这个组合命令，将博客上传到github上。 当你打开浏览器，输入your_user_name.github.io，就可以看到你托管到平台上的数据了。 关于博客主题模版 网上有各种各样的模版，我用的NexT, 参照官方文档进行配置就可以了。目前博客还在完善，特此记录本博客的搭建经历。 关于管理博客内容 参照Hexo官方文档 最后以后简书会同步更新这个博客的内容。 复习本博客链接：shawenlx.github.io]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UITableView+FDTemplateLayoutCell 源码探究]]></title>
      <url>%2F2016%2F11%2F27%2FUITableView-FDTemplateLayoutCell-%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6%2F</url>
      <content type="text"><![CDATA[UITableView+FDTemplateLayoutCell 源码探究 在我们日常的业务中，常常伴随大量的UITableView，然而动态地计算Cell的高度常常困扰着我。自从使用了这个组件之后，一切都变得没那么复杂。所以深入学习下这个框架的组件的实现原理。 框架地址：https://github.com/forkingdog/UITableView-FDTemplateLayoutCell 代码文件目录12345678- UITableView+FDIndexPathHeightCache.h- UITableView+FDIndexPathHeightCache.m- UITableView+FDKeyedHeightCache.h- UITableView+FDKeyedHeightCache.m- UITableView+FDTemplateLayoutCell.h- UITableView+FDTemplateLayoutCell.m- UITableView+FDTemplateLayoutCellDebug.h- UITableView+FDTemplateLayoutCellDebug.m 首先，介绍一下这几个类的基本功能，再层层推进，逐一分析。 1234- UITableView+FDIndexPathHeightCache，主要负责cell通过NSIndexPath进行缓存高度的功能- UITableView+FDKeyedHeightCache，主要负责cell通过key值进行缓存高度的功能- UITableView+FDTemplateLayoutCell，提供接口方法方便用户定义cell的数据源，以及帮助我们计算cell的高度- UITableView+FDTemplateLayoutCellDebug，提供一些Debug打印信息 关于这个框架，坦白说，从代码中看，作者无疑秀了一波runtime底层的功底，让我这种小白起初一脸懵逼。自然我得换种思路来解读这个框架，那就是从字数最少的类入手吧。 UITableView+FDTemplateLayoutCellDebug123456789@interface UITableView (FDTemplateLayoutCellDebug)//设置Debug模式是否打开@property (nonatomic, assign) BOOL fd_debugLogEnabled;//通过该方法，传递NSLog打印对应的Debug信息- (void)fd_debugLog:(NSString *)message;@end 1234567891011121314151617@implementation UITableView (FDTemplateLayoutCellDebug)- (BOOL)fd_debugLogEnabled &#123; return [objc_getAssociatedObject(self, _cmd) boolValue];&#125;- (void)setFd_debugLogEnabled:(BOOL)debugLogEnabled &#123; objc_setAssociatedObject(self, @selector(fd_debugLogEnabled), @(debugLogEnabled), OBJC_ASSOCIATION_RETAIN);&#125;- (void)fd_debugLog:(NSString *)message &#123; if (self.fd_debugLogEnabled) &#123; NSLog(@"** FDTemplateLayoutCell ** %@", message); &#125;&#125;@end 在分类中，如果要声明属性，可以通过使用关联度对象( AssociatedObject ), 通过objc_setAssociatedObject() 添加属性，objc_getAssociatedObject() 获取属性。实际上，相当于在运行时系统中动态地在内存中开辟一块空间，存储debugLogEnabled这个BOOL变量，类似懒加载的方式，通过runtime实现setter &amp; getter方法。 关于runtime的知识点，推荐这篇博客:http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/ UITableView+FDKeyedHeightCache1234567891011121314151617181920212223#import &lt;UIKit/UIKit.h&gt;@interface FDKeyedHeightCache : NSObject//判断缓存中是否存在key为值的缓存高度- (BOOL)existsHeightForKey:(id&lt;NSCopying&gt;)key;//对指定key的cell设置高度为height- (void)cacheHeight:(CGFloat)height byKey:(id&lt;NSCopying&gt;)key;//从缓存中获取对应key的cell的高度height值- (CGFloat)heightForKey:(id&lt;NSCopying&gt;)key;//从缓存中删除指定key的cell的值- (void)invalidateHeightForKey:(id&lt;NSCopying&gt;)key;//移除缓存中所有的cell的高度缓存值- (void)invalidateAllHeightCache;@end@interface UITableView (FDKeyedHeightCache)@property (nonatomic, strong, readonly) FDKeyedHeightCache *fd_keyedHeightCache;@end 先来看看FDKeyedHeightCache类中声明的属性 123@property (nonatomic, strong) NSMutableDictionary&lt;id&lt;NSCopying&gt;, NSNumber *&gt; *mutableHeightsByKeyForPortrait;@property (nonatomic, strong) NSMutableDictionary&lt;id&lt;NSCopying&gt;, NSNumber *&gt; *mutableHeightsByKeyForLandscape; 不难看出，这是两个指定泛型的可变字典。 mutableHeightsByKeyForPortrait : 用于缓存设备竖直放置时，对应key的cell的高度值。 mutableHeightsByKeyForLandscape : 用于缓存设备横向放置时，对应key的cell的高度值。 FDKeyedHeightCache中的接口方法 1234567891011121314151617181920212223242526- (BOOL)existsHeightForKey:(id&lt;NSCopying&gt;)key &#123; NSNumber *number = self.mutableHeightsByKeyForCurrentOrientation[key]; return number &amp;&amp; ![number isEqualToNumber:@-1];&#125;- (void)cacheHeight:(CGFloat)height byKey:(id&lt;NSCopying&gt;)key &#123; self.mutableHeightsByKeyForCurrentOrientation[key] = @(height);&#125;- (CGFloat)heightForKey:(id&lt;NSCopying&gt;)key &#123;#if CGFLOAT_IS_DOUBLE return [self.mutableHeightsByKeyForCurrentOrientation[key] doubleValue];#else return [self.mutableHeightsByKeyForCurrentOrientation[key] floatValue];#endif&#125;- (void)invalidateHeightForKey:(id&lt;NSCopying&gt;)key &#123; [self.mutableHeightsByKeyForPortrait removeObjectForKey:key]; [self.mutableHeightsByKeyForLandscape removeObjectForKey:key];&#125;- (void)invalidateAllHeightCache &#123; [self.mutableHeightsByKeyForPortrait removeAllObjects]; [self.mutableHeightsByKeyForLandscape removeAllObjects];&#125; 这些方法并不晦涩，看到这里，大家不禁会问，self.mutableHeightsByKeyForCurrentOrientation从何而来，这也是我觉得这个类中，细节处理比较好的地方，由于此处考虑到缓存的高度区别了设备方向，所以框架作者，通过一个getter方法来获取对应的存放高度的字典。 123- (NSMutableDictionary&lt;id&lt;NSCopying&gt;, NSNumber *&gt; *)mutableHeightsByKeyForCurrentOrientation &#123; return UIDeviceOrientationIsPortrait([UIDevice currentDevice].orientation) ? self.mutableHeightsByKeyForPortrait: self.mutableHeightsByKeyForLandscape;&#125; 根据UIDeviceOrientationIsPortrait()函数，传入当前设备的放置方向（[UIDevice currentDevice].orientation ）进行判断。从而便可以通过属性简洁判断需要从那个字典中取值了。 UITableView+FDIndexPathHeightCache1234567891011121314151617181920212223@interface FDIndexPathHeightCache : NSObject// 如果您使用索引路径获取高度缓存，则自动启用@property (nonatomic, assign) BOOL automaticallyInvalidateEnabled;// Height cache- (BOOL)existsHeightAtIndexPath:(NSIndexPath *)indexPath;- (void)cacheHeight:(CGFloat)height byIndexPath:(NSIndexPath *)indexPath;- (CGFloat)heightForIndexPath:(NSIndexPath *)indexPath;- (void)invalidateHeightAtIndexPath:(NSIndexPath *)indexPath;- (void)invalidateAllHeightCache;@end@interface UITableView (FDIndexPathHeightCache)@property (nonatomic, strong, readonly) FDIndexPathHeightCache *fd_indexPathHeightCache;@end@interface UITableView (FDIndexPathHeightCacheInvalidation)/// 当你不想通过删除缓存中的高度来刷新数据源重新计算时，可以调用这个方法。/// 该方法中用过runtime重写了tableView中修改cell的一些方法，例如插入cell，删除cell，移动cell，以及reloadData方法。- (void)fd_reloadDataWithoutInvalidateIndexPathHeightCache;@end 首先看看FDIndexPathHeightCache中设置的属性 123456typedef NSMutableArray&lt;NSMutableArray&lt;NSNumber *&gt; *&gt; FDIndexPathHeightsBySection;@interface FDIndexPathHeightCache ()@property (nonatomic, strong) FDIndexPathHeightsBySection *heightsBySectionForPortrait;@property (nonatomic, strong) FDIndexPathHeightsBySection *heightsBySectionForLandscape;@end 通过前面key的高度缓存分析，不难猜出这几个属性是干什么的。 由于通过NSIndexPath获取高度缓存，NSIndexPath对应section, 以及indexPath。FDIndexPathHeightsBySection这个数组，通过数组嵌套字典的数据结构来存储，不同的section组中对应的cell的高度缓存。 FDIndexPathHeightCache中的方法 由于头文件声明的几个接口方法，与FDKeyedHeightCache中的思路类似，就不再费口舌了，大家翻看源码便一目了然。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (void)enumerateAllOrientationsUsingBlock:(void (^)(FDIndexPathHeightsBySection *heightsBySection))block &#123; block(self.heightsBySectionForPortrait); block(self.heightsBySectionForLandscape);&#125;- (void)invalidateHeightAtIndexPath:(NSIndexPath *)indexPath &#123; [self buildCachesAtIndexPathsIfNeeded:@[indexPath]]; [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection &#123; heightsBySection[indexPath.section][indexPath.row] = @-1; &#125;];&#125;- (void)invalidateAllHeightCache &#123; [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123; [heightsBySection removeAllObjects]; &#125;];&#125;- (void)buildCachesAtIndexPathsIfNeeded:(NSArray *)indexPaths &#123; // Build every section array or row array which is smaller than given index path. [indexPaths enumerateObjectsUsingBlock:^(NSIndexPath *indexPath, NSUInteger idx, BOOL *stop) &#123; [self buildSectionsIfNeeded:indexPath.section]; [self buildRowsIfNeeded:indexPath.row inExistSection:indexPath.section]; &#125;];&#125;- (void)buildSectionsIfNeeded:(NSInteger)targetSection &#123; [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123; for (NSInteger section = 0; section &lt;= targetSection; ++section) &#123; if (section &gt;= heightsBySection.count) &#123; heightsBySection[section] = [NSMutableArray array]; &#125; &#125; &#125;];&#125;- (void)buildRowsIfNeeded:(NSInteger)targetRow inExistSection:(NSInteger)section &#123; [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123; NSMutableArray&lt;NSNumber *&gt; *heightsByRow = heightsBySection[section]; for (NSInteger row = 0; row &lt;= targetRow; ++row) &#123; if (row &gt;= heightsByRow.count) &#123; heightsByRow[row] = @-1; &#125; &#125; &#125;];&#125; 这几个封装的方法，主要一点就是通过block来回调，判断删除NSIndexPath对应的cell高度缓存。 在这个类中，最核心的莫过于UITableView (FDIndexPathHeightCacheInvalidation) 这个分类的实现细节，废话少说，继续看代码。 1234567//我们只是转发主调用，在崩溃报告中，最顶层的方法在堆栈可能存在FD，//但它真的不是我们的错误，你应该检查你的表视图的数据源和//重新加载时显示单元格不匹配。static void __FD_TEMPLATE_LAYOUT_CELL_PRIMARY_CALL_IF_CRASH_NOT_OUR_BUG__(void (^callout)(void)) &#123; callout();&#125;#define FDPrimaryCall(...) do &#123;__FD_TEMPLATE_LAYOUT_CELL_PRIMARY_CALL_IF_CRASH_NOT_OUR_BUG__(^&#123;__VA_ARGS__&#125;);&#125; while(0) 调用的接口方法 123- (void)fd_reloadDataWithoutInvalidateIndexPathHeightCache &#123; FDPrimaryCall([self fd_reloadData];);&#125; 这个方法，主要调用的是［self fd_reloadData］，看到这里的时候，我们的第一反应应该是此处通过runtime 交换了系统方法的实现。这是一种动态的拦截技巧，也算是基础的runtime知识了，懵逼的小伙伴可以认真阅读下前面提到的关于runtime的大牛博文。 既然如此，先来看看作者重写了哪些系统的方法吧。 12345678910111213141516171819202122+ (void)load &#123; // All methods that trigger height cache's invalidation SEL selectors[] = &#123; @selector(reloadData), @selector(insertSections:withRowAnimation:), @selector(deleteSections:withRowAnimation:), @selector(reloadSections:withRowAnimation:), @selector(moveSection:toSection:), @selector(insertRowsAtIndexPaths:withRowAnimation:), @selector(deleteRowsAtIndexPaths:withRowAnimation:), @selector(reloadRowsAtIndexPaths:withRowAnimation:), @selector(moveRowAtIndexPath:toIndexPath:) &#125;; for (NSUInteger index = 0; index &lt; sizeof(selectors) / sizeof(SEL); ++index) &#123; SEL originalSelector = selectors[index]; SEL swizzledSelector = NSSelectorFromString([@"fd_" stringByAppendingString:NSStringFromSelector(originalSelector)]); Method originalMethod = class_getInstanceMethod(self, originalSelector); Method swizzledMethod = class_getInstanceMethod(self, swizzledSelector); method_exchangeImplementations(originalMethod, swizzledMethod); &#125;&#125; 通过method_exchangeImplementations() C函数， 将重写的方法，一一交换成重写的方法。 在这些fd_方法中的实现细节中，需要注意的一点就是，如果对应的fd_indexPathHeightCache设置了automaticallyInvalidateEnabled属性为YES时，对应的方法对高度缓存做相应的处理，重新更新fd_indexPathHeightCache中存储的高度缓存。 当第一次reloadData，或者cell的行数发生变化（增减行，section) ，会先在tableview不处于滚动状态的时候异步计算那些没有被计算过的cell的高度，做预缓存，这个想法非常赞。 使用者需要小心，这些调用是异步的, tableview delegate有可能会在预缓存计算的时候不存在了，导致程序崩溃，所以使用者在tableview需要析构的时候，在对应的tableview controller的dealloc中讲self.tableview.delegate = nil；，确保delegate后续不会是一个野指针。 UITableView+FDTemplateLayoutCell至此，我们已经分析了几个子类的实现逻辑，唯一剩下一个分类，也是我们使用这个框架的入口 FDTemplateLayoutCell分类。全面了解这个组件近在咫尺。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@interface UITableView (FDTemplateLayoutCell)/* 为给定的重用标识符访问内部模板布局单元格。 * 一般来说，你不需要知道这些模板布局单元格。 * @param identifier重用必须注册的单元格的标识符。*/ - (__kindof UITableViewCell *)fd_templateCellForReuseIdentifier:(NSString *)identifier;/* 返回由重用标识符指定并配置的类型的单元格的高度, 并通过block来配置。 * 单元格将被放置在固定宽度，垂直扩展的基础上，相对于其动态内容，使用自动布局。 * 因此，这些必要的单元被设置为自适应，即其内容总是确定它的宽度给定的宽度等于tableview的宽度。 * @param identifier用于检索和维护模板的字符串标识符cell通过系统方法 * '- dequeueReusableCellWithIdentifier：' * @param configuration用于配置和提供内容的可选块到模板单元格。 * 配置应该是最小的滚动性能足以计算单元格的高度。*/- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier configuration:(void (^)(id cell))configuration;/* 计算的高度将通过其索引路径进行高速缓存，当需要时返回高速缓存的高度，因此，可以节省大量额外的高度计算。 * 无需担心数据源更改时使缓存高度无效，它将在调用“-reloadData”或任何触发方法时自动完成UITableView的重新加载。 * @param indexPath此单元格的高度缓存所属的位置。*/- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByIndexPath:(NSIndexPath *)indexPath configuration:(void (^)(id cell))configuration;/* 此方法通过模型实体的标识符缓存高度。 * 如果你的模型改变，调用“-invalidateHeightForKey:(id &lt;NSCopying&gt;)key”到无效缓存并重新计算，它比“cacheByIndexPath”方便得多。 * @param key model entity的标识符，其数据配置一个单元格。*/ - (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByKey:(id&lt;NSCopying&gt;)key configuration:(void (^)(id cell))configuration;@end@interface UITableView (FDTemplateLayoutHeaderFooterView)/* 返回在具有重用标识符的表视图中注册的Header或Footer视图的高度。 * 在调用“ - [UITableView registerNib / Class：forHeaderFooterViewReuseIdentifier]”之后使用它， * 与“-fd_heightForCellWithIdentifier：configuration：”相同。 * 它将调用“-sizeThatFits：” * UITableViewHeaderFooterView的子类不使用自动布局。*/ - (CGFloat)fd_heightForHeaderFooterViewWithIdentifier:(NSString *)identifier configuration:(void (^)(id headerFooterView))configuration;@end@interface UITableViewCell (FDTemplateLayoutCell)/* 指示这是仅用于计算的模板布局单元格。 * 当配置单元格时，如果有非UI的副作用，你可能需要这个。 * 类似: * - (void)configureCell:(FooCell *)cell atIndexPath:(NSIndexPath *)indexPath &#123; * cell.entity = [self entityAtIndexPath:indexPath]; * if (!cell.fd_isTemplateLayoutCell) &#123; * [self notifySomething]; // non-UI side effects * &#125; * &#125;*/@property (nonatomic, assign) BOOL fd_isTemplateLayoutCell;/* 启用以强制此模板布局单元格使用“框架布局”而不是“自动布局”， * 并且通过调用“-sizeThatFits：”来询问单元格的高度，所以你必须重写这个方法。 * 仅当要手动控制此模板布局单元格的高度时才使用此属性 * 计算模式，默认为NO。*/@property (nonatomic, assign) BOOL fd_enforceFrameLayout;@end 先来看看我们平时开发中最频繁调用的两个方法 (CGFloat)fd_heightForCellWithIdentifier:(NSString )identifier cacheByIndexPath:(NSIndexPath )indexPath configuration:(void (^)(id cell))configuration; (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByKey:(id)key configuration:(void (^)(id cell))configuration; 12345678910111213141516171819202122232425262728293031- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByIndexPath:(NSIndexPath *)indexPath configuration:(void (^)(id cell))configuration &#123; if (!identifier || !indexPath) &#123; return 0; &#125; // Hit cache if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123; return [self.fd_indexPathHeightCache heightForIndexPath:indexPath]; &#125; CGFloat height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration]; [self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath]; return height;&#125;- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByKey:(id&lt;NSCopying&gt;)key configuration:(void (^)(id cell))configuration &#123; if (!identifier || !key) &#123; return 0; &#125; // Hit cache if ([self.fd_keyedHeightCache existsHeightForKey:key]) &#123; CGFloat cachedHeight = [self.fd_keyedHeightCache heightForKey:key]; return cachedHeight; &#125; CGFloat height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration]; [self.fd_keyedHeightCache cacheHeight:height byKey:key]; return height;&#125; 这两个方法，分别是对cell通过NSIndexPath 或者 key值 进行高度缓存，读取高度的时候，先从缓存cache中读取，如果缓存中没有，在通过[self fd_heightForCellWithIdentifier:identifier configuration:configuration]方法进行计算高度并加入缓存中。 12345678910111213141516- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier configuration:(void (^)(id cell))configuration &#123; if (!identifier) &#123; return 0; &#125; UITableViewCell *templateLayoutCell = [self fd_templateCellForReuseIdentifier:identifier]; //手动调用以确保与实际单元格的一致行为。 （显示在屏幕上） [templateLayoutCell prepareForReuse]; if (configuration) &#123; configuration(templateLayoutCell); &#125; return [self fd_systemFittingHeightForConfiguratedCell:templateLayoutCell];&#125; 通过blocks进行配置并计算cell的高度，主要通过[self fd_templateCellForReuseIdentifier:identifier]方法创建一个UITableViewCell的实例templateLayoutCell，最后再把templateLayoutCell放入[self fd_systemFittingHeightForConfiguratedCell:templateLayoutCell]中进行计算返回高度。 12345678910111213141516171819202122- (__kindof UITableViewCell *)fd_templateCellForReuseIdentifier:(NSString *)identifier &#123; NSAssert(identifier.length &gt; 0, @"Expect a valid identifier - %@", identifier); NSMutableDictionary&lt;NSString *, UITableViewCell *&gt; *templateCellsByIdentifiers = objc_getAssociatedObject(self, _cmd); if (!templateCellsByIdentifiers) &#123; templateCellsByIdentifiers = @&#123;&#125;.mutableCopy; objc_setAssociatedObject(self, _cmd, templateCellsByIdentifiers, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; UITableViewCell *templateCell = templateCellsByIdentifiers[identifier]; if (!templateCell) &#123; templateCell = [self dequeueReusableCellWithIdentifier:identifier]; NSAssert(templateCell != nil, @"Cell must be registered to table view for identifier - %@", identifier); templateCell.fd_isTemplateLayoutCell = YES; templateCell.contentView.translatesAutoresizingMaskIntoConstraints = NO; templateCellsByIdentifiers[identifier] = templateCell; [self fd_debugLog:[NSString stringWithFormat:@"layout cell created - %@", identifier]]; &#125; return templateCell;&#125; 将所有创建的templateCell放置在一个字典templateCellsByIdentifiers中，并通过runtime将其加入内存中作为属性，实际上，templateCell 也是通过identifier在复用队列中获取复用的。所以，cell在使用前，应先注册为cell的复用对象。 最后调用的[self fd_systemFittingHeightForConfiguratedCell:templateLayoutCell]进行高度计算。当然也是最关键的一个操作，既然这是一个高度计算的框架，那么计算的步骤当然是重中之重。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (CGFloat)fd_systemFittingHeightForConfiguratedCell:(UITableViewCell *)cell &#123; CGFloat contentViewWidth = CGRectGetWidth(self.frame); if (cell.accessoryView) &#123; //如果有定制accessoryView，则去除这个宽度 contentViewWidth -= 16 + CGRectGetWidth(cell.accessoryView.frame); &#125; else &#123; //如果有系统accessoryView展示，则去除对应的宽度。 static const CGFloat systemAccessoryWidths[] = &#123; [UITableViewCellAccessoryNone] = 0, [UITableViewCellAccessoryDisclosureIndicator] = 34, [UITableViewCellAccessoryDetailDisclosureButton] = 68, [UITableViewCellAccessoryCheckmark] = 40, [UITableViewCellAccessoryDetailButton] = 48 &#125;; contentViewWidth -= systemAccessoryWidths[cell.accessoryType]; &#125; CGFloat fittingHeight = 0; if (!cell.fd_enforceFrameLayout &amp;&amp; contentViewWidth &gt; 0) &#123; //如果是自动布局，则将contentView的宽度约束添加进去。 //这样做的目的是让UILabel之类的内容可能多行的控件适应这个宽度折行（当然前提是我们已经设置好了这些控件的布局约束）。然后调用systemLayoutSizeFittingSize来计算高度。 //最后移除刚才临时添加的contentView宽度约束。 NSLayoutConstraint *widthFenceConstraint = [NSLayoutConstraint constraintWithItem:cell.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:contentViewWidth]; [cell.contentView addConstraint:widthFenceConstraint]; fittingHeight = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height; [cell.contentView removeConstraint:widthFenceConstraint]; &#125; if (fittingHeight == 0) &#123; // 尝试调用 '- sizeThatFits:'进行高度计算. // 注意：配件高度不应包括分隔线视图高度。 fittingHeight = [cell sizeThatFits:CGSizeMake(contentViewWidth, 0)].height; &#125; // 进行完前面的逻辑后高度如果仍然为0，则使用默认行高44 if (fittingHeight == 0) &#123; fittingHeight = 44; &#125; // 添加一像素作为tableView分割线高度。 if (self.separatorStyle != UITableViewCellSeparatorStyleNone) &#123; fittingHeight += 1.0 / [UIScreen mainScreen].scale; &#125; return fittingHeight;&#125; 至此，就大致将这个框架分析的差不多了，源码中，对类的实例化均为采用runtime添加AssociatedObject的方式。就不做解释了。 最后 赏花不忘种花人，把作者关于这个框架优秀的性能分析复习下。 地址：http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/ ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NSOperation：初识]]></title>
      <url>%2F2016%2F08%2F09%2FNSOperation%EF%BC%9A%E5%88%9D%E8%AF%86%2F</url>
      <content type="text"><![CDATA[NSOperation的简介NSOperation的抽象程度高于NSThread，它是苹果对线程的一个面向对象封装。NSOperation表示一个独立的计算单元，作为一个抽象类，你需要实例化他的子类 : NSInvocationOperation / NSBlockOperation 来进行具体操作。实例化之后，调用start方法或者加入到一个NSOperationQueue 操作队列中，就可以开始执行。 NSOperation的使用 启动NSInvocationOperation 123// 如果直接调用operation的start方法，是在主线程上运行，不会开启新的线程NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(threadLoadImage:) object:imageView];[operation start]; 使用NSOperationQueue管理NSOperation并开启一个异步线程 12// 定义操作队列属性@property (strong, nonatomic) NSOperationQueue *queue; 12// 实例化操作队列self.queue = [[NSOperationQueue alloc] init]; 12// 初始化一个NSInvocationOperationNSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(threadLoadImage:) object:imageView]; 12// 将NSInvocationOperation添加到队列，一添加到队列，就会开启新线程执行任务，不可以同时使用start[self.queue addOperation:operation]; 使用NSOperationQueue管理并NSBlockOperation开启一个线程 更偏向于使用NSBlockOperation，原因在于通过使用代码块会更方便一些，本质上和NSInvocationOperation没有区别。 1234// 初始化一个NSBlockOperationNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123; // 异步操作 [self operationLoadImage:imageView];&#125;];// 添加操作到队列中[self.queue addOperation:operation]; 在主线程中执行操作 12345//可通过该＋方法 获取系统主线程，通常我们刷新UI界面进行绘制的时候，必须在主线程下完成。+ (NSOperationQueue *)mainQueue NS_AVAILABLE(10_6, 4_0);//该＋号方法可以获取当前使用线程+ (nullable NSOperationQueue *)currentQueue NS_AVAILABLE(10_6, 4_0); 1234// 在主线程队列上更新UI[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; [imageView setImage:image];&#125;]; 通过 addDependency：添加线程之间的依赖关系 Tip: 直接在队列中添加操作会并发执行，执行顺序是系统调用决定的，在特定的时候我们需要控制操作的执行顺序，就会使用到addDependency操作。addDependency: 是NSOperation的成员方法，调用该方法的NSOperation对象将在参数执行完成之后执行。需要先添加依赖关系，再将操作添加到队列中。 12345678910111213141516171819202122// 初始化三个块操作 NSBlockOperation *op1 =[NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"下载 %@", [NSThread currentThread]); &#125;]; NSBlockOperation *op2 =[NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"美化 %@", [NSThread currentThread]); &#125;]; NSBlockOperation *op3 =[NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"更新 %@", [NSThread currentThread]); &#125;]; // 通过添加依赖可以控制线程执行顺序，依赖关系可以多重依赖 // 注意：不要建立循环依赖，会造成死锁 [op2 addDependency:op1]; [op3 addDependency:op2]; // 直接加到队列里面会并发执行，谁先先后是系统调用决定 [self.operationQueue addOperation:op3]; [self.operationQueue addOperation:op1]; [self.operationQueue addOperation:op2]; 控制线程并发数 12// 并发的线程越多越耗资源，队列可以设置同时并发线程的数量，来进行控制self.queue.maxConcurrentOperationCount = 2; 取消线程操作 NSOperation里有一系列的属性用来标明自身状态的，isReady → isExecuting →isFinish。线程start后并不是立即执行，而是进入一个就绪的状态（isReady），由系统调度执行。 12//有时可能需要进行取消操作，可以调用– (void)cancel; 来停止一些还未执行的不必要的线程。[operation cancel]; 为NSOperation添加完成代码块 123operation.completionBlock = ^&#123; NSLog(@"completion!");&#125;; NSOperation的优先级 123456789101112131415161718//同NSThread一样，NSOperation可以通过threadPriority属性来指定优先级。//但是在IOS8，线程这个概念已经被苹果框架系统性的忽略了，threadPriority已由NSQualityOfService属性替代.typedef NS_ENUM(NSInteger, NSQualityOfService) &#123; /* 和图形处理相关的任务，比如滚动和动画 */ NSQualityOfServiceUserInteractive = 0x21, /* 用户请求的任务，但是不需要精确到毫秒级。例如如果用户请求打开电子邮件App来查看邮件 */ NSQualityOfServiceUserInitiated = 0x19, /* 周期性的用户请求任务。比如，电子邮件App可能被设置成每5分钟自动检测新邮件。但是在系统资源极度匮乏的时候，将这个周期性的任务推迟几分钟也没有大碍*/ NSQualityOfServiceUtility = 0x11, /* 后台任务，对这些任务用户可能并不会察觉，比如电子邮件App对邮件进行索引以方便搜索 */ NSQualityOfServiceBackground = 0x09, /* 默认的优先级 */ NSQualityOfServiceDefault = -1&#125; NS_ENUM_AVAILABLE(10_10, 8_0); NSOperation优势 NSOperation方便控制线程执行顺序 使用NSBlockOperation可以使用块代码，不必单写线程方法，便于传递多个参数 可以控制线程并发数，有效地对线程进行控制 可以添加线程完成代码块，执行需要的操作 对比GCD 和 NSOperation虽然GCD已经成为流行， 但是在某些框架中，例如AFNetworking还是使用的NSOperation来完成线程相关的操作，除了使用框架的NSInvocationOperation / NSBlockOperation 来处理线程操作，你也可以通过自定义集成来完成你需要的操作。 关于NSOperation博客的传送门http://www.cnblogs.com/kenshincui/p/3983982.html#NSOperationhttp://nshipster.cn/ios8/http://nshipster.cn/nsoperation/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于链表的一些逻辑思维]]></title>
      <url>%2F2016%2F06%2F09%2F%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E9%80%BB%E8%BE%91%E6%80%9D%E7%BB%B4%2F</url>
      <content type="text"><![CDATA[写这个东西的原因 大学也即将毕业了，很多算法和数据结构的东西可能在iOS开发中并不能用得上，曾经有颗去BAT的心，错过了校招，希望厚积薄发，两三年后或许还有机会。记录下，那些大学里为之痴迷的东西。 什么是链表？ 对于计算机而言，大多数数据和信号的存储方式是离散的。那么今天要介绍的链表，就是一种离散结构的数据结构。与之对应的数组，是一种连续的数据结构。 先来看一张相对形象的图。 定义链表的节点 由于链表是由多个链表节点，连接而成。先看看如何定义一个节点吧，其实就是个结构体。 1234typedef struct Node &#123; int val; //数据域 struct Node *next; //指针域&#125;pNode; 一个节点中包含数据域和指针域，数据域用于存储节点的数据信息，而指针next则指向下一个节点的地址。从内存的角度来看，它便是离散的，因为指向的下一块内存不是连续的。 如何创建单链表 一条单链表中，必不可少的是头节点，相当于一个标记。个人习惯在头节点保存链表节点的个数 123456//creat a listinline Node *creat() &#123; Node *head = (Node *)malloc(sizeof(Node *)); head-&gt;next = NULL; //防止野指针 return head;&#125; 关于malloc（）,我们可以通过这个函数对头节点分配堆上的内存空间用于存储节点信息。而sizeof关键字就是计算需要分配多少的空间了。这个地方存在一个字节对齐的问题。感兴趣的同学可以深入理解。 链表的插入 头插法，效率高，也是C++ STL中使用的一种方式。 尾插法，效率低，只是介绍下，毕竟还是有区别的。 头插法 我们可以猜测，既然是头部插入，那我们插入的元素顺序就是逆序的。 12345678910//头插法，时间复杂度O(1)inline void push_front(Node *head, const int _val) &#123; if (!head) return ; //判断链表是否存在，通过头指针是否为空 Node *nNode = (Node *)malloc(sizeof(Node *)); nNode-&gt;val = _val; Node *pNode = head-&gt;next; nNode-&gt;next = pNode; head-&gt;next = nNode; ++head-&gt;val;//统计节点个数&#125; 尾插法 既然是尾部插入，那我们插入的元素顺序就是顺序的。 12345678910111213//尾插法，时间复杂度O(n) inline void push_back(Node *head, const int _val) &#123; if (!head) return ; Node *nNode = (Node *)malloc(sizeof(Node *)); nNode-&gt;val = _val; Node *pNode = head; while (pNode-&gt;next) &#123; pNode = pNode-&gt;next; &#125; pNode-&gt;next = nNode; nNode-&gt;next = NULL; ++head-&gt;val;//统计节点个数 &#125; 我们不难发现，之所以时间复杂度为O(n)，是因为，每次比头插法多花了一个while循环来遍历链表，直到找到链表的最后一个节点。 链表删除节点 任何一种数据结构，必不可少的都包含增删查改的功能。删除也是链表操作中较为复杂的一个操作。时间复杂度即为查找删除节点的遍历的复杂度。 12345678910111213141516171819//删除链表中第一个值为_val的节点inline void remove(Node *head, const int _val) &#123; if (!head || !head-&gt;next) return ; Node *pNode = head; while (pNode-&gt;next) &#123; if (pNode-&gt;next-&gt;val == _val) &#123; //找到要删除的元素 Node *dNode = pNode-&gt;next; pNode-&gt;next = dNode-&gt;next; if (!dNode-&gt;next) &#123; pNode-&gt;next = NULL; &#125; free(dNode); --head-&gt;val;//更新节点统计 break; &#125; pNode = pNode-&gt;next; &#125;&#125; 关于链表的一些巧妙应用 偷懒：至于什么判断链表是不是为空，链表节点个数，或者查找链表中某个元素是否存在的函数，我就懒得介绍了。接下来看几个有趣的应用。 如何判断单链表是否存在自环 这是前两年大公司非常喜欢问的一道题目，何谓自环？就是在链表中形成了一个循环。 对于这个问题，有一个很棒的思路， 那就是采用两个指针，一个指针从head开始，另一个从head-&gt;next开始，第一个指针每次只走一步，第二个指针每次走两步。正常不存在环的情况下，以第二个指针到达尾节点作为判断的依据，若是存在环，那必定这两个指针会相遇，那么指针相遇便能作为判断单链表中存在环的依据。 1234567891011//判断单链表中是否存在自环 1代表存在，0则反之。inline int judge_circle(Node *head) &#123; if (!head || !head-&gt;next) return 0; Node *first = head-&gt;next, *second = head-&gt;next-&gt;next; while (second &amp;&amp; first) &#123; if (first == second) return 1; second = second-&gt;next-&gt;next; first = first-&gt;next; &#125; return 0;&#125; 该算法的时间复杂度是O(n)的。也就是最多只会遍历一次链表。附上Leetcode题目地址：https://leetcode.com/problems/linked-list-cycle/ 翻转整条单链表 操作结果便是将 1-&gt;2-&gt;3-&gt;4-&gt;NULL 转换为 4-&gt;3-&gt;2-&gt;1-&gt;NULL. 思路很简单，无非就是指针操作，采用两个指针反复修改指向就可以了。Leetcode题目地址：https://leetcode.com/problems/reverse-linked-list/ 12345678910111213141516171819//翻转整条链表,时间复杂度为O(n)inline Node *reverse(Node *head) &#123; if (!head || !head-&gt;next) return head; Node *pNode = head, *qNode = pNode-&gt;next; pNode-&gt;next = NULL; if (!qNode-&gt;next) &#123; head = qNode; qNode-&gt;next = pNode; return head; &#125; while (qNode-&gt;next) &#123; head = qNode-&gt;next; qNode-&gt;next = pNode; pNode = qNode; qNode = head; &#125; head-&gt;next = pNode; return head;&#125; 总结：先记录这么多吧，还有些题目暂时还没时间去整理出来。接下来有时间会持续更新。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为什么我选择使用Blocks]]></title>
      <url>%2F2016%2F06%2F08%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8Blocks%2F</url>
      <content type="text"><![CDATA[扯淡：到了新公司接手新框架之后，发现大量的使用Blocks，之前很多时候都是使用代理，突然面对这个陌生的语法，特地科普总结了一番。 什么是Blocks 一句话概括就是，带有局部变量的匿名函数（即不带名称的函数）。也称为闭包。 Blocks语法 ^ 返回值类型 参数列表 表达式 12//例如^int (int count) &#123; return count + 1; &#125; 上述表达式中，返回值类型 以及 参数列表可以省略(如下), 语法加粗表明不可缺少的部分。 123^ &#123; printf("Hello, blocks");&#125; 将Blocks声明为属性 多数情况下，我们会把Blocks声明为属性，便于调用。可以利用关键字typedef 对Blocks进行别名。 12typedef 返回值类型 (^Blocks别名)(参数列表);typedef int (^blk_t)(int); 12//将Blocks声明为属性@property (nonatomic, copy) blk_t blk; 12//对Blocks进行声明定义blk = ^(int count) &#123; return count + 1; &#125;; 12//调用Blocks 和 调用C语言声明函数方式一样NSLog(@"%d\n", blk(10)); 将Blocks作为参数传入方法中 通常都会事先为Blocks取一个别名，一来方便理解，好吧不装逼，就是偷懒。 1234567//定义：typedef void(^Block)(int a);- (void)nslogParameterWithBlock:(Block)block &#123; if (block) &#123; block(10); &#125;&#125; 1234//赋值并调用[object nslogParameterWithBlock:^(int a) &#123; NSLog(@"%d", a);&#125;]; Blocks截获自动变量值 什么是截获自动变量值，所谓自动变量，就是局部变量。那为什么会截获呢？先来看个例子。 1234int val = 10;void (^block)(void) = ^ &#123; printf("val = %d", val); &#125;;val = 20;block(); //此处调用block，打印为val = 10； 之所以没有打印val = 20，是因为该Blocks在编译期就进行了初始化，对声明的val进行截获，也就是说，把val拷贝一份存入Blocks中。所以当外部val进行了修改时，不影响Blocks截获的val值。 __block 关键字 从上个例子中，我们知道Blocks会对变量进行截获。那如果我非要在Blocks中修改外部参数怎么办呢？我们可以通过__block关键字做到！ 1234__block int val = 10;void (^block)(void) = ^ &#123; printf("val = %d", val); &#125;;val = 20;block(); //此处调用block，打印为val = 20; 通过__block说明符对外部参数进行声明后，实际上，相当于在声明定义Blocks的时候，不是通过拷贝内存的方式拷贝外部参数，而是通过指针指向该外部变量，从而达到可以在Blocks中修改的效果。 总结： Blocks使用方便，但是block的内存管理确实是一项非常重要也非常容易出错的地方，稍不注意便会造成内存泄露，所以，在使用Blocks的时候，也要小心。 因为是匿名函数，所以在项目中多人合作的时候，最后写上每个Blocks的注释说明。 后续将继续总结Blocks的内存管理内容。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS UICollectionView瀑布流]]></title>
      <url>%2F2016%2F06%2F06%2FiOS-UICollectionView%E7%80%91%E5%B8%83%E6%B5%81%2F</url>
      <content type="text"><![CDATA[一、UICollectionViewLayout基础知识 如果要自定义UICollectionViewLayout，需要实现以下几个方法，按初始化layout后，系统执行顺序排列： 12// 初始化layout后自动调动，可以在该方法中初始化一些自定义的变量参数 - (void)prepareLayout; 12// 设置UICollectionView的内容大小，道理与UIScrollView的contentSize类似 - (CGSize)collectionViewContentSize; 12// 初始Layout外观，返回所有的布局属性 - (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect; 12// 根据不同的indexPath，给出布局 - (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath; 二、瀑布流布局 逻辑与原理 123456逻辑其实很简单，就是给出每一个cell的坐标。想要定位一个控件，需要CGRectMake四个参数：y : 首先我们看到的这个demo是两列的，所以肯定有两个Y轴起始点，分为左侧和右侧。x : 然后除Y轴不同外，左侧和右侧的X轴也不相同。width : 关于width我们可以通过一行两列，然后每一个cell的间距来得到。height: height是在collectionView中定义的，layout获得不到，所以我们选择用代理，在collectionView中设置。 需要的定义的变量 12345@property (assign, nonatomic) CGFloat leftY; // 左侧起始Y轴@property (assign, nonatomic) CGFloat rightY; // 右侧起始Y轴@property (assign, nonatomic) NSInteger cellCount; // cell个数@property (assign, nonatomic) CGFloat itemWidth; // cell宽度@property (assign, nonatomic) CGFloat insert; // 间距 代理的定义 1234567@class WaterfallFlowLayout;@protocol WaterfallFlowLayoutDelegate &lt;NSObject&gt;@required- (CGSize)collectionView:(UICollectionView *)collectionView collectionViewLayout:(sWaterfallFlowLayout *)collectionViewLayout sizeOfItemAtIndexPath:(NSIndexPath *)indexPath;@end 布局方法的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 初始化layout后自动调动，可以在该方法中初始化一些自定义的变量参数 */- (void)prepareLayout &#123; [super prepareLayout]; // 初始化参数 _cellCount = [self.collectionView numberOfItemsInSection:0]; // cell个数，直接从collectionView中获得 _insert = 10; // 设置间距 _itemWidth = (SCREEN_WIDTH - 3 * _insert) / 2; // cell宽度&#125;/** * 设置UICollectionView的内容大小，道理与UIScrollView的contentSize类似 * @return 返回设置的UICollectionView的内容大小 */- (CGSize)collectionViewContentSize &#123; return CGSizeMake(SCREEN_WIDTH, MAX(_leftY, _rightY));&#125;/** * 初始Layout外观 * @param rect 所有元素的布局属性 * @return 所有元素的布局 */- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect &#123; _leftY = _insert; // 左边起始Y轴 _rightY = _insert; // 右边起始Y轴 NSMutableArray *attributes = [[NSMutableArray alloc] init]; for (int i = 0; i &lt; self.cellCount; i ++) &#123; NSIndexPath *indexPath = [NSIndexPath indexPathForRow:i inSection:0]; [attributes addObject:[self layoutAttributesForItemAtIndexPath:indexPath]]; &#125; return attributes;&#125;/** * 根据不同的indexPath，给出布局 * @param indexPath * @return */- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath &#123; // 获取代理中返回的每一个cell的大小 CGSize itemSize = [self.delegate collectionView:self.collectionView collectionViewLayout:self sizeOfItemAtIndexPath:indexPath]; // 防止代理中给的size.width大于(或小于)layout中定义的width，所以等比例缩放size CGFloat itemHeight = floorf(itemSize.height * self.itemWidth / itemSize.width); UICollectionViewLayoutAttributes *attributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; // 判断当前的item应该在左侧还是右侧 BOOL isLeft = _leftY &lt; _rightY; if (isLeft) &#123; CGFloat x = _insert; attributes.frame = CGRectMake(x, _leftY, _itemWidth, itemHeight); _leftY += itemHeight + _insert; // 设置新的Y起点 &#125; else &#123; CGFloat x = _itemWidth + 2 * _insert; attributes.frame = CGRectMake(x, _rightY, _itemWidth, itemHeight); _rightY += itemHeight + _insert; &#125; return attributes;&#125; Demo地址https://github.com/shawenlx/WaterfallFlowCollection]]></content>
    </entry>

    
  
  
</search>
