<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[变色龙：CAGradientLayer]]></title>
      <url>%2F2016%2F12%2F15%2F%E5%8F%98%E8%89%B2%E9%BE%99%EF%BC%9ACAGradientLayer%2F</url>
      <content type="text"><![CDATA[项目需求​ 最近项目中需要绘制一根颜色渐变的挂线，当然也可以让UI设计做图，不过考虑到如果渐变色采用一种会变化的展示效果也许会更加炫酷些。绘制这根挂线，CAGradientLayer是不二之选。 关于CAGradientLayer​ CAGradientLayer可以用来生成两种或更多颜色平滑渐变的Layer。使用Layer层的绘制，有一个很明显的优势就是：绘制过程采用了硬件加速。 CAGradientLayer的相关属性123456789101112131415161718192021222324252627282930313233@interface CAGradientLayer : CALayer/* 存放每个渐变分割点的CGColorRef对象数组. 数组默认为nil. 可支持动画. */@property(nullable, copy) NSArray *colors;/* 一个可选的NSNumber对象数组，定义每个对象的位置梯度分割点作为范围[0,1]中的值。 * 值必须为单调递增的。 如果给出一个nil数组，分割点在[0,1]范围内均匀分布。 * 当呈现时，在颜色被映射到输出颜色空间之前插值。 数组默认为nil。 支持动画。 * locations数组并不是强制要求的，但是如果你给它赋值了就一定要确保locations的数组大小和colors数组大小一定要相同，否则你将会得到一个空白的渐变。 */@property(nullable, copy) NSArray&lt;NSNumber *&gt; *locations;/* 绘制到图层中时渐变的开始点和结束点的坐标空间。 * 起始点对应于第一梯度停止，终点到最后一个梯度停止。 * 两点都是在单位坐标空间中定义，然后映射到图层的边界矩形。 （即[0,0]是左下角的，[1,1]是右上角。） * 默认值分别是[.5,0]和[.5,1]。 默认支持的是竖直方向。两者都支持动画。 */@property CGPoint startPoint;@property CGPoint endPoint;/* 将绘制的渐变的种类。 目前唯一允许value是`axial'（默认值）。 */@property(copy) NSString *type;@end /** `type' values. **/CA_EXTERN NSString * const kCAGradientLayerAxial CA_AVAILABLE_STARTING (10.6, 3.0, 9.0, 2.0);NS_ASSUME_NONNULL_END CAGradientLayer坐标系​ 渐变色的作用范围，变化梯度的方向，颜色变换的作用点都和CAGradientLayer的坐标系统有关。根据下图的坐标，设定好起点和终点，渐变色的方向就会根据起点指向终点的方向来渐变了。 CAGradientLayer的坐标系统是从（0，0）到（1，1）绘制的矩形 CAGradientLayer的frame值的size不为正方形的话，坐标系统会被拉伸 CAGradientLayer的startPoint和endPoint会直接决定颜色的绘制方向 CAGradientLayer的颜色分割点时以0到1的比例来计算的 CAGradientLayer渐变方向12@property CGPoint startPoint;@property CGPoint endPoint; 可以通过设置startPoint 以及 endPoint来设置渐变的方向，可以是水平方向的，也可以是竖直方向的，当然也可以沿着对角线进行渐变。系统默认支持的是竖直方向。 颜色渐变的水平线 通过CAGradientLayer 绘制一根颜色渐变的水平线。并通过CABasicAnimation执行颜色移动的动画。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#import "ViewController.h"#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width@interface ViewController () &lt;CAAnimationDelegate&gt;@property (nonatomic, strong) CAGradientLayer *lineLayer;@property (nonatomic, strong) UIView *lineView;@property (nonatomic, strong) NSMutableArray *colorsArray;@property (nonatomic, strong) CABasicAnimation *gradientAnimation;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor blackColor]; [self.view addSubview:self.lineView]; [self.lineLayer addAnimation:self.gradientAnimation forKey:@"gradientAnimate"];&#125;- (void)configAnimation &#123; //将颜色数组中的最后一个元素加入到第一个元素中，达到颜色移动的效果。 id lastColor = self.colorsArray.lastObject; [self.colorsArray removeLastObject]; [self.colorsArray insertObject:lastColor atIndex:0]; self.lineLayer.colors = self.colorsArray; [self.lineLayer addAnimation:self.gradientAnimation forKey:@"gradientAnimate"];&#125;#pragma mark - &lt;CAAnimationDelegate&gt;- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag &#123; [self configAnimation];&#125;#pragma mark - getter - (CAGradientLayer *)lineLayer &#123; if (!_lineLayer) &#123; _lineLayer = [CAGradientLayer layer]; _lineLayer.frame = self.lineView.frame; _lineLayer.startPoint = CGPointMake(0.0, 0.5); _lineLayer.endPoint = CGPointMake(1.0, 0.5); _lineLayer.colors = self.colorsArray; &#125; return _lineLayer;&#125;- (NSMutableArray *)colorsArray &#123; if (!_colorsArray) &#123; _colorsArray = [NSMutableArray array]; for (NSInteger hue = 0; hue != 360; hue += 5) &#123; UIColor *color = [UIColor colorWithHue:1.0 * hue / 360.0 saturation:1.0 brightness:1.0 alpha:1.0]; [_colorsArray addObject:(__bridge id)[color CGColor]]; &#125; &#125; return _colorsArray;&#125;- (UIView *)lineView &#123; if (!_lineView) &#123; _lineView = [[UIView alloc] initWithFrame:CGRectMake(0, 120, SCREEN_WIDTH, 1)]; [_lineView.layer addSublayer:self.lineLayer]; &#125; return _lineView;&#125;- (CABasicAnimation *)gradientAnimation &#123; if (!_gradientAnimation) &#123; _gradientAnimation = [CABasicAnimation animationWithKeyPath:@"colorsAnimation"]; _gradientAnimation.delegate = self; _gradientAnimation.duration = 0.06; _gradientAnimation.toValue = self.colorsArray; [_gradientAnimation setRemovedOnCompletion:YES]; _gradientAnimation.fillMode = kCAFillModeForwards; &#125; return _gradientAnimation;&#125;@end 代码效果图 总结 其实这个小实验只是个人的自娱自乐。对于Layer的学习仍需要不断积累。多数复杂的动画都是基于简单动画的组合和扩展。 另外，有一个不错的学习教材。iOS Core Animation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我所认识的Hash]]></title>
      <url>%2F2016%2F12%2F14%2F%E6%88%91%E6%89%80%E8%AE%A4%E8%AF%86%E7%9A%84Hash%2F</url>
      <content type="text"><![CDATA[我所认识的Hash 前言​ 关于Hash表，是我们经常会碰到的数据结构。大多数时候，它能高效地解决我们的一些实际问题。当然，多数情况下时间和空间正如鱼和熊掌，不可兼得。只有在特定的情况下，我们去选择适合当前需求的数据结构和算法。 ​ Hash表本质是可以理解为键值对的集合。key-value一一对应。 字符Hash的简单应用 先来看这样一个简单的例子，有一个字符串，仅有大写字母’A’~’Z’组成，我们需要对这个字符串中所有的字母进行统计。然后输出对应的表，如 ACAADEB, 则A-&gt;3, B-&gt;1, C-&gt;1, D-&gt;1, E-&gt;1。 那么如何来做这个统计呢，这时候Hash表就可以派上用场了。字符‘A’对应的ASCII码为65，那么根据Hash的思想，我们可以把一个数组中的下标映射为字符，将下标对应的值中存储我们的统计结果，比如Hash[‘A’] = 3; 1234567int hash[26];string str = "ACAADEB";void count_char_on_string(string &amp;str) &#123; for (int i = 0; i &lt; str.length(); ++i) &#123; ++hash[str[i] - 'A']; &#125;&#125; 通过以上这个代码，我们就能将字符串中的字符一一统计下来。贯彻的思想就是将字符映射成数组下标。 字符串Hash 既然能够将字符映射成整数，那么肯定有办法将字符串也映射成整数。 关于字符串hash算法，有很多种，可以通过这篇博客了解，不同的字符串hash算法的对比。各种字符串Hash函数比较 此处，我仅仅以BKDRHash算法作为例子，核心的思想是通过一个选择器，我们也成为种子(seed)，通常选择种子应该是一个质数，如31， 131，1313等，这样的好处在于减少不同字符串映射为相同整数的冲突。通过一个计算公式，将不同的字符串进行转化为数字。 1234567891011// BKDR Hash Functionunsigned int BKDRHash(char *str) &#123; unsigned int seed = 131; // 31 131 1313 13131 131313 etc.. unsigned int hash = 0; while (*str) &#123; //每转化一位字符，用当前的hash值 * seed，在加上字符的ASCII码。 //hash * seed, 此处我们可以理解为当前字符串在前一个字符串hash值的基础上，偏移了一个种子的数级距离。 hash = hash * seed + (*str++); &#125; return (hash &amp; 0x7FFFFFFF); //最后用hash &amp; Ox7FFFFFFF 确保hash值在unsigned int 范围中。&#125; 利用字符串Hash可以解决很多问题，可以做字符串匹配。效率也蛮高的，相比KMP算法或者后缀数组和AC自动机等数据结构，它也不失为一种巧妙的办法。我们可以通过将每一位计算得到的hash偏移值存储在一个数组里，然后通过计算偏移得到子串的hash值，在和匹配串的hash值进行对比，如果相同，则说明匹配成功。 12345678910111213typedef unsigned long long ull;ull hash[1000]; //假设字符串长度小于1000ull char_hash[1000]; //存储对应字符的hash值inline ull cal_hash(string &amp;str, const int l, const int r) &#123; if (l == 0) return cal_hash[r]; ull seed = 131; hash[0] = 0; for (int i = 1; i &lt; str.length(); ++i) &#123; hash[i] = hash[i-1] * seed; //计算偏移 &#125; //用当前r对应的char_hash值-减去当前子串前一部分多计算的偏移hash值。就能得到子串的hash值了。 return char_hash[r] - char_hash[l-1] * hash[r-l+1];&#125; 解决字符串Hash冲突 或多或少，BKDRHash算法在极小的几率下会出现Hash冲突，解决的办法有很多，多数时候，我们采用邻接表来解决这个问题。 由于算法涉及&amp;操作，会有导致冲突的可能。在多串匹配的情况下，我们需要将所有匹配字符串计算得到的hash值，存放到邻接表中，所谓的邻接表就是数组套链表。将计算到的匹配串hash值作为数组中的值，并加入到对应的链表中，如果我们计算到的hash值出现冲突的情况，就往对应链表中加入新的节点。在后续匹配的情况下，进行查找链表并做多一次简单的匹配即可。 关于Hash的一个有趣应用 有这么一个4 * 4的棋盘，棋子有两种状态，黑色或白色。我们这个时候也可以通过Hash来记录当前棋盘的信息。 那么对应的棋盘，我们用1表示黑色，用0表示白色。那么就有： 这个图转化成矩阵就是： ​ 1 0 1 0 ​ 0 0 0 0 ​ 1 1 0 1 ​ 1 0 0 1 那么如何转化成整数来记录棋盘呢？ ​ 2^0 2^1 2^2 2^3 ​ 2^4 2^5 2^6 2^7 ​ 2^8 2^9 2^10 2^11 ​ 2^12 2^13 2^14 2^15 最后得到的棋盘我们可以通过判断当前棋子颜色，如果是黑色，则在对应位n上加上对应的2^n, n可以通过行列式计算出来。 12345int state[4][4]; //预处理记录棋子状态unsigned int hash = 0;for (int i = 0; i &lt; 16; ++i) &#123; hash += state[i/4][i%4] * (1 &lt;&lt; i);&#125; 这样我们就把棋盘信息转化成一个整数了。 最后​ 关于Hash表仍有很多的应用，还有一种应用是搜索领域，如何将互联网上大量的字符串存储，这里推荐大家了解一下字典树，它也是基于Hash算法的思想的数据结构。在iOS中，NSDictionary就是基于Hash的实现。以后有机会会深入CF框架看看实现源码，到时候再来分享。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016年的点滴记录]]></title>
      <url>%2F2016%2F12%2F12%2F2016%E5%B9%B4%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95%2F</url>
      <content type="text"><![CDATA[前言​ 2016已经接近尾声，最近时常在想，今年我都忙活了一些什么。写下这些的目的仅仅是为了记录过去一年自己的收获，以及总结一些不足。当然更重要的是对2017做一个展望和规划。 大学毕业​ 乐观点想，这也算完成了人生中一个比较有意义的里程碑——大学毕业！虽说只是一所普通的二本院校，不过从拍摄毕业照，穿戴学士服到顺利获赠毕业证学位证，蛮开心的！消极地说，也算是完成了爸爸妈妈这么多年对我的一个期待，当然啦，离你们的期望或许还差得远，按照妈妈的玩笑话，大概你现在吹虚自己孩子的成绩时，可能唯有学历张不了口。半开玩笑，也许这两口子肯定想着这娃总算能不用从我们荷包里拿零花钱了。哈哈。而对于我而言，我既怀念校园生活那种轻松自由的氛围，也对踏入社会充满信心，有挑战便会有机会！ ​ 关于自己的大学四年，是否真的是学有所成这样的一个问题。我思考了很长时间，到最后也没有一个准确的答案。有大一时候那种散漫懒散，也有后来的挑灯夜战。经历过了就是经历过了，不该有任何一点后悔。虽没有达到非常高的水平，但也算见识了高山，认识到自己仍有很多不足，既有崇拜的技术大牛，也有较长期的学习计划。我不该在此处记录下这样一句，诸如“我尽力了”的话，接下来会更加高效地运用自己的时间和规划自己的学习 生活。 ​ 大学里，如今剩下的记忆，大概就只有实验室和哥们一起比赛刷题的时光，以及楼下的烧烤摊。感谢他们几个人，给我的生活带了很多乐趣，如今也各奔东西了，希望各自安好！ ​ 毕业时，才清楚地认识到，其实同班同学和我并不熟悉。他们对我的认识，我猜大概就是从一个纨绔子弟变成了一个代码狂魔。所以最后分别的时光，我聚餐也没有去，因为那里不属于我。大学里，我体会孤独，所以有时候和别人谈起自己的学习经历时，我有时候甚至会有这样的想法，你朋友太多，聚会太多注定你没办法更专注地做好一件事情。 ​ 回想起高考落榜，本下定决心要复读，不过老爸一句“你不适合读书，别浪费时间”，我至今都记得！说起这件事，四年过去了，我只是想感谢老爸！的确为我多争取了一年时间进入互联网行业，如今的大环境竞争越来越激烈，市场也越来越饱和，这一年很重要，甚至决定了我从事互联网行业，而不是去当一个销售！这一点，大概也就他能预想到，因为我一直觉得爸爸是最懂我的，也是最支持我的！即使是一向贯彻的严厉家教，似乎也让我比别人对待自己事情的时候，多了一点要求和高一点标准，总想尽力做到接近完美。 工作生活​ 从2015年11月正式实习，说句心里话，从事iOS前端开发不是我的本意。我原本热衷地想做服务器开发，解决高并发，提高系统性能。这大概是绝大多数Acmer的追求吧，骨子里总有一点鄙视前端开发，不过现在没有了，因为前端也有很多性能优化，有很多的底层技术。以前的认识大概只是“管中窥豹，可见一斑”。底层技术在一些程序员眼中，是块硬骨头，对我而言，这是乐趣！我并不是为了重复造轮子，我或许只是担心轮子万一坏了，我能修好它。况且刨根问底本就该是一个有追求的程序员最基本的素养！ ​ 今年从第一家公司辞职，发生了很多不愉快的事情。原来的老板和我同样承受了损失，当然他的损失更大，我也仅仅是半个月薪水。当时，厚着脸皮要回上一个月的工资只有两个想法。第一，我需要这笔钱买一张回深圳的飞机票，因为这一家公司，我对成都的互联网有了很多不好的认识和理解，也可以说是偏见吧。第二，我需要这笔钱支付我的学业贷款以及过度我在找到下一家工作前的基本开销。我是出于这两个目的才去讨要工资的，但是原来的老板做法不是很义气！甚至口放狂言侮辱我，蛮有意思的。在这家公司，iOS开发居然有这样的约束，不让我写他看不懂的代码，不让我动手改良产品框架，因为他觉得浪费时间，仅仅只是复制粘贴实现功能，而大多数时候讨论的结果仅仅以一句“你要和我配合就得按照我的来”，所以后来的代码估计没人能维护了，因为他的封装思想就是把功能代码复制粘贴到工程里，因为这样的开发氛围，我曾一度想放弃iOS。 ​ 从辞职到找到新工作，花了一星期不到的时间。回想起面试过程，还真是捏了一把汗。挺难的，底层技术居多，不过幸运的是这一块自己平时涉猎比较多，所以回答还算满意。当然也聊到一些比较有意思的优化方案，提出一些自己对算法的理解和认识。中间聊到一些常用的开源框架，面试官很直接地问这些底层细节是怎么实现的，当时的回答差强人意，也就一笔带过了。研究开源框架是我这段时间正在进行的学习计划。在这个公司，目前总体还是蛮顺利的，工作压力也没有特别大，身边的小伙伴也都比我优秀，希望继续保持！多交流多学习多总结。 ​ 薪水目前不是我考虑要不要来这家公司的主要依据，面对面试官提出那么多有深度的问题，我很乐意加入这个团队，以至于接到offer电话的时候，HR还没开口说薪酬待遇我已经点头欢喜答应了。事实上，我还没去过BAT，目前的公司给了我很多的发挥空间，也随着运营推广用户量在不断提升。会用心去做好每一个需求，优化自己能想到的地方，然后完善项目架构，整理一套适用于自己的项目规范和封装库，这一点仍需要积累经验不断努力！ 关于爱情​ 弟弟刚结婚，对我而言，也算是一种激励吧！我也想早点成立自己的家庭，凡事量力而行，希望两年后能完成这件终身大事，并且希望能靠自己的积蓄完成。爸妈谋生养家并不容易，我倒是希望他们自己留点闲钱退休周游全国。也希望自己早日结束异地恋，过上真正朝夕相伴，患难同甘的生活。 关于技术​ 关于前端，其实我觉得很多东西是相通的。iOS中也有很多时候需要和web交互，接下来的一段时间，会多抽出一点时间学学Html,CSS以及Javascript。然后严格执行目前罗列的iOS源码阅读计划，静下心来沉淀一段时间。量变到质变是一个很漫长的过程，哪怕一个月只更新一两篇博客，对自己也是一种习惯的培养，和技术的总结。开设这个博客收获还是蛮多的，也算是每天有点挂念吧，鼓励自己多去接触一些技术知识！ 展望2017​ 多花一点时间学习，少想一些不切实际的“蓝图”。认认真真做事情，踏实低调做人。 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[说一些你也许不知道的DZNEmptyDataSet细节]]></title>
      <url>%2F2016%2F12%2F07%2F%E8%AF%B4%E4%B8%80%E4%BA%9B%E4%BD%A0%E4%B9%9F%E8%AE%B8%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84DZNEmptyDataSet%E7%BB%86%E8%8A%82%2F</url>
      <content type="text"><![CDATA[前言：​ 关于这个框架，之所以分析它的源码，只是想知道这么几个问题：它是如何做到自动检测UITableView以及UICollectionView是否存在数据并且响应刷新界面，以及兼顾系统方法和框架的封装和处理技巧。让我们带着这些问题一起来看看源码吧。 关于框架 Github源码地址: https://github.com/dzenbot/DZNEmptyDataSet 版本：1.8.1 点击该链接查看如何使用这个框架 文件目录 UIScrollView+EmptyDataSet.h UIScrollView+EmptyDataSet.m 粗略地浏览下头文件，发现核心的部分主要是实现两个协议，分别为DZNEmptyDataSetSource和DZNEmptyDataSetDelegate。这两个协议中的协议方法均为@optional类型。 12345678910111213@interface UIScrollView (EmptyDataSet)@property (nonatomic, weak) IBOutlet id &lt;DZNEmptyDataSetSource&gt; emptyDataSetSource;@property (nonatomic, weak) IBOutlet id &lt;DZNEmptyDataSetDelegate&gt; emptyDataSetDelegate;/** YES if any empty dataset is visible. */@property (nonatomic, readonly, getter = isEmptyDataSetVisible) BOOL emptyDataSetVisible;/** *调用UITableView或者UICollectionView的［-reloadData］方法便会相应此方法。 *并且 当且仅当列表数据源为空的时候才会触发。 */- (void)reloadEmptyDataSet;@end DZNEmptyDataSetSource 该协议主要作用于数据源为空时的对空白界面元素的设置。 其中包括对Title、description、image、imageTintColor、imageAnimation、buttonTitle、buttonImage等属性的设置。 该协议提供了一套配置的接口，既方便用户根据需求设置相应的样式，当然也提供了**自定义界面的接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 设置默认空白界面处理视图的标题Title. * 若需要设置富文本，则返回时设置(NSAttributedString *)类型。 */- (NSAttributedString *)titleForEmptyDataSet:(UIScrollView *)scrollView;/** * 设置默认空白界面处理视图的描述description文本。 * 若需要设置富文本，则返回时设置(NSAttributedString *)类型。 */- (NSAttributedString *)descriptionForEmptyDataSet:(UIScrollView *)scrollView;/** * 设置默认空白界面布局的图片。 */- (UIImage *)imageForEmptyDataSet:(UIScrollView *)scrollView;/** * 设置默认空白界面布局图片的前景色，默认为nil. */- (UIColor *)imageTintColorForEmptyDataSet:(UIScrollView *)scrollView;/** * 设置默认空白界面图片的动画效果。 */- (CAAnimation *) imageAnimationForEmptyDataSet:(UIScrollView *) scrollView;/** * 设置默认空白界面响应按钮的标题，通常我们可以设置为"重新加载"等文本。 * 如果需要显示不同的标题样式，可以返回富文本。 * 并传入UIControlState进行设置。点击或者普通状态等。 */- (NSAttributedString *)buttonTitleForEmptyDataSet:(UIScrollView *)scrollView forState:(UIControlState)state;/** * 设置默认空白界面响应按钮的图片。 * 并传入UIControlState进行设置。点击或者普通状态等。 */- (UIImage *)buttonImageForEmptyDataSet:(UIScrollView *)scrollView forState:(UIControlState)state;/** * 设置默认空白界面响应按钮的背景图片。默认不设置。 * 并传入UIControlState进行设置。点击或者普通状态等。 */- (UIImage *)buttonBackgroundImageForEmptyDataSet:(UIScrollView *)scrollView forState:(UIControlState)state;/** * 设置默认空白界面的背景颜色。默认为[UIColor clearColor] */- (UIColor *)backgroundColorForEmptyDataSet:(UIScrollView *)scrollView;/** * 设置默认空白界面的自定义视图View, View中可以高度自定义，包括按钮图片以及标题等元素。 * 并传入UIControlState进行设置。点击或者普通状态等。 * 返回自定义视图，将会忽略以下方法的配置。 * -offsetForEmptyDataSet 和 -spaceHeightForEmptyDataSet */- (UIView *)customViewForEmptyDataSet:(UIScrollView *)scrollView;/** * 设置界面的垂直和水平方向的对齐约束， 默认为CGPointZero */- (CGPoint)offsetForEmptyDataSet:(UIScrollView *)scrollView DEPRECATED_MSG_ATTRIBUTE("Use -verticalOffsetForEmptyDataSet:");- (CGFloat)verticalOffsetForEmptyDataSet:(UIScrollView *)scrollView;/** * 设置界面元素的垂直间距，默认为11px。 */- (CGFloat)spaceHeightForEmptyDataSet:(UIScrollView *)scrollView; 开个小玩笑，我从未使用过该框架自带的样式，多数时候我们的需求还是以自定义为主，当然啦，这并不影响我们阅读源码，带着愉快地心情解读一下该框架优秀的地方也是蛮不错的。 DZNEmptyDataSetDelegate 该协议主要作用于处理该空白界面的代理。用于获取代理的响应回调。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 实现该方法告诉代理EmptyDataSetView显示时以淡入的模式，默认为YES。 */- (BOOL)emptyDataSetShouldFadeIn:(UIScrollView *)scrollView;/** * 实现该方法告诉代理EmptyDataSetView显示时应该被渲染。默认为YES。 */- (BOOL)emptyDataSetShouldDisplay:(UIScrollView *)scrollView;/** * 实现该方法告诉代理该视图可以响应点击事件，默认为YES。 */- (BOOL)emptyDataSetShouldAllowTouch:(UIScrollView *)scrollView;/** * 实现该方法告诉代理该视图允许滚动，默认为NO。 */- (BOOL)emptyDataSetShouldAllowScroll:(UIScrollView *)scrollView;/** * 实现该方法告诉代理该视图中的图片允许执行动画，默认为NO。 */- (BOOL)emptyDataSetShouldAnimateImageView:(UIScrollView *)scrollView;/** * 实现该方法告诉代理emptyDataSetView被点击 * 使用该方法要么对textfield或者searchBar调用了resignFirstResponder方法。 */- (void)emptyDataSetDidTapView:(UIScrollView *)scrollView DEPRECATED_MSG_ATTRIBUTE("Use emptyDataSet:didTapView:");/** * 实现该方法告诉代理，响应按钮点击事件被触发 * @param scrollView 该滚动视图的子类实现了该方法。 */- (void)emptyDataSetDidTapButton:(UIScrollView *)scrollView DEPRECATED_MSG_ATTRIBUTE("Use emptyDataSet:didTapButton:");/** * 实现该方法告诉代理empty dataset view被点击触发。 * 使用该方法要么对textfield或者searchBar调用了resignFirstResponder方法。 */- (void)emptyDataSet:(UIScrollView *)scrollView didTapView:(UIView *)view;/** * 实现该方法告诉代理，响应按钮点击事件被触发 */- (void)emptyDataSet:(UIScrollView *)scrollView didTapButton:(UIButton *)button;/** * 实现该方法告诉代理，emptyDataView视图即将出现。 */- (void)emptyDataSetWillAppear:(UIScrollView *)scrollView;/** * 实现该方法告诉代理，emptyDataView视图已经出现。 */- (void)emptyDataSetDidAppear:(UIScrollView *)scrollView;/** * 实现该方法告诉代理，emptyDataView视图即将消失。 */- (void)emptyDataSetWillDisappear:(UIScrollView *)scrollView;/** * 实现该方法告诉代理，emptyDataView视图已经消失。 */- (void)emptyDataSetDidDisappear:(UIScrollView *)scrollView; 不知道大家有没有注意到，这些代理方法均以emptyDataSet作为方法前缀，相信我们写UITableView的代理方法非常频繁吧，那你一定也能注意到这样一个编程规范，这样做的好处在于我们可以利用自动补全提示的功能快速索引我们想要的方法。这些细节还是有很多品味咀嚼的地方，必须引起我们的高度重视，这样才能写出更规范的代码。 看到这里，相信你对如何实现协议方法来实现你的目的已经不是大问题，然而这还远远不够。当我打开.m文件，猛然觉得接口方法仅是冰山一角，有一个更大的宝藏藏在实现文件中，继续细细品味。 123456789101112131415161718@interface UIView (DZNConstraintBasedLayoutExtensions)- (NSLayoutConstraint *)equallyRelatedConstraintWithView:(UIView *)view attribute:(NSLayoutAttribute)attribute;@end@interface DZNEmptyDataSetView : UIView//...@end#pragma mark - UIScrollView+EmptyDataSetstatic char const * const kEmptyDataSetSource = "emptyDataSetSource";static char const * const kEmptyDataSetDelegate = "emptyDataSetDelegate";static char const * const kEmptyDataSetView = "emptyDataSetView";#define kEmptyImageViewAnimationKey @"com.dzn.emptyDataSet.imageViewAnimation"@interface UIScrollView () &lt;UIGestureRecognizerDelegate&gt;@property (nonatomic, readonly) DZNEmptyDataSetView *emptyDataSetView;@end 实现文件中，主要包含以上三个类。请”自动忽略”掉前两个类。无关紧要，主要功能是设置该框架的界面元素以及布局约束，代码也容易理解，自行打开框架源码查看，便不做赘述，着重记录介绍UIScrollView+EmptyDataSet这个分类的实现。 UIScrollView+EmptyDataSet先浏览下这个分类中的代码模块。阅读源码的时候应该从大方向入手，看看代码分块主要包含哪些模块，再逐一突破。换言之，先找到入口，再慢慢探索！ 12345678910#pragma mark - Getters (Public)#pragma mark - Getters (Private)#pragma mark - Data Source Getters#pragma mark - Delegate Getters &amp; Events (Private)#pragma mark - Setters (Public)#pragma mark - Setters (Private)#pragma mark - Reload APIs (Public)#pragma mark - Reload APIs (Private)#pragma mark - Method Swizzling#pragma mark - UIGestureRecognizerDelegate Methods #pragma mark - Getters (Public)123456789101112- (id&lt;DZNEmptyDataSetSource&gt;)emptyDataSetSource &#123; return objc_getAssociatedObject(self, kEmptyDataSetSource);&#125;- (id&lt;DZNEmptyDataSetDelegate&gt;)emptyDataSetDelegate &#123; return objc_getAssociatedObject(self, kEmptyDataSetDelegate);&#125;- (BOOL)isEmptyDataSetVisible &#123; UIView *view = objc_getAssociatedObject(self, kEmptyDataSetView); return view ? !view.hidden : NO;&#125; 该模块主要通过runtime获取属性设置DZNEmptyDataSetSource，DZNEmptyDataSetDelegate 以及isEmptyDataSetVisible的属性getter方法。 isEmptyDataSetVisible属性主要用于判断当前的EmptyDataSetView是否可见。这里的!view.hidden是返回YES的，默认初始化EmptyDataSetView的hidden为YES，默认不可见。在后面的setter方法中可以看到。 #pragma mark - Setters (Public)12345678910111213141516171819202122- (void)setEmptyDataSetSource:(id&lt;DZNEmptyDataSetSource&gt;)datasource &#123; if (!datasource || ![self dzn_canDisplay]) &#123; [self dzn_invalidate]; &#125; objc_setAssociatedObject(self, kEmptyDataSetSource, datasource, OBJC_ASSOCIATION_ASSIGN); // 通过添加runtime替换原生的-reloadData方法的实现方法为-dzn_reloadData方法。 [self swizzleIfPossible:@selector(reloadData)]; // 特别注意的是对于UITableView, 我们也注入方法-dzn_reloadData到-endUpdates方法中。 if ([self isKindOfClass:[UITableView class]]) &#123; [self swizzleIfPossible:@selector(endUpdates)]; &#125;&#125;- (void)setEmptyDataSetDelegate:(id&lt;DZNEmptyDataSetDelegate&gt;)delegate &#123; if (!delegate) &#123; [self dzn_invalidate]; &#125; objc_setAssociatedObject(self, kEmptyDataSetDelegate, delegate, OBJC_ASSOCIATION_ASSIGN);&#125; 这两个Setter方法，主要通过runtime对两个代理属性进行设置。 [self dzn_invalidate]为移除视图的方法。 [self dzn_canDisplay]为判断父视图是否为UITableView, UICollectionView以及UIScrollView。 关于方法如何替换交换将在下面分析。 #pragma mark - Getters (Private)12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (DZNEmptyDataSetView *)emptyDataSetView &#123; DZNEmptyDataSetView *view = objc_getAssociatedObject(self, kEmptyDataSetView); if (!view) &#123; view = [DZNEmptyDataSetView new]; //... [self setEmptyDataSetView:view]; &#125; return view;&#125;- (BOOL)dzn_canDisplay &#123; if (self.emptyDataSetSource &amp;&amp; [self.emptyDataSetSource conformsToProtocol:@protocol(DZNEmptyDataSetSource)]) &#123; if ([self isKindOfClass:[UITableView class]] || [self isKindOfClass:[UICollectionView class]] || [self isKindOfClass:[UIScrollView class]]) &#123; return YES; &#125; &#125; return NO;&#125;- (NSInteger)dzn_itemsCount &#123; NSInteger items = 0; // UIScollView 没有响应 'dataSource' 方法，所以不进行统计 if (![self respondsToSelector:@selector(dataSource)]) &#123; return items; &#125; // UITableView support if ([self isKindOfClass:[UITableView class]]) &#123; UITableView *tableView = (UITableView *)self; id &lt;UITableViewDataSource&gt; dataSource = tableView.dataSource; NSInteger sections = 1; if (dataSource &amp;&amp; [dataSource respondsToSelector:@selector(numberOfSectionsInTableView:)]) &#123; sections = [dataSource numberOfSectionsInTableView:tableView]; &#125; if (dataSource &amp;&amp; [dataSource respondsToSelector:@selector(tableView:numberOfRowsInSection:)]) &#123; for (NSInteger section = 0; section &lt; sections; section++) &#123; items += [dataSource tableView:tableView numberOfRowsInSection:section]; &#125; &#125; &#125; // UICollectionView support else if ([self isKindOfClass:[UICollectionView class]]) &#123; //...类似于UITableView的处理方式。 &#125; return items;&#125; (DZNEmptyDataSetView *)emptyDataSetView通过runtime初始化mptyDataSetView，并设置了一些默认的属性参数 (BOOL)dzn_canDisplay判断当前视图是否可以加载空白页面，当且仅当self实现了代理，以及为UITableView, UICollectionVIew和UIScrollView. (NSInteger)dzn_itemsCount统计self的dataSource的元素个数，通过- numberOfSections和 - numberOfItemsInSection方法进行统计。 #pragma mark - Setters (Private)123- (void)setEmptyDataSetView:(DZNEmptyDataSetView *)view&#123; objc_setAssociatedObject(self, kEmptyDataSetView, view, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125; 通过runtime设置私有View。 #pragma mark - Data Source Getters12345678910111213141516171819202122232425262728293031323334- (NSAttributedString *)dzn_titleLabelString;- (NSAttributedString *)dzn_detailLabelString;- (UIImage *)dzn_image; - (CAAnimation *)dzn_imageAnimation;- (UIColor *)dzn_imageTintColor;- (NSAttributedString *)dzn_buttonTitleForState:(UIControlState)state;- (UIImage *)dzn_buttonImageForState:(UIControlState)state;- (UIImage *)dzn_buttonBackgroundImageForState:(UIControlState)state;- (UIColor *)dzn_dataSetBackgroundColor;- (CGFloat)dzn_verticalOffset;- (CGFloat)dzn_verticalSpace;- (UIView *)dzn_customView &#123; if (self.emptyDataSetSource &amp;&amp; [self.emptyDataSetSource respondsToSelector:@selector(customViewForEmptyDataSet:)]) &#123; UIView *view = [self.emptyDataSetSource customViewForEmptyDataSet:self]; if (view) NSAssert([view isKindOfClass:[UIView class]], @"You must return a valid UIView object for -customViewForEmptyDataSet:"); if (!self.isNotFirst) &#123; self.isNotFirst = YES; return nil; &#125; return view; &#125; return nil;&#125; 该模块的方法主要通过DataSource的代理方法设置对应的系统默认的View的属性。 - dzn_customView用于设置自定义视图，也是我们最常用的一个方法。同样也是通过协议方法获取对应的自定义视图。 #Delegate Getters &amp; Events (Private)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374- (BOOL)dzn_shouldFadeIn &#123; //... return YES;&#125;- (BOOL)dzn_shouldDisplay &#123; //... return YES;&#125;- (BOOL)dzn_isTouchAllowed &#123; //... return YES;&#125;- (BOOL)dzn_isScrollAllowed &#123; //... return NO;&#125;- (BOOL)dzn_isImageViewAnimateAllowed &#123; if (self.emptyDataSetDelegate &amp;&amp; [self.emptyDataSetDelegate respondsToSelector:@selector(emptyDataSetShouldAnimateImageView:)]) &#123; return [self.emptyDataSetDelegate emptyDataSetShouldAnimateImageView:self]; &#125; return NO;&#125;- (void)dzn_willAppear &#123; if (self.emptyDataSetDelegate &amp;&amp; [self.emptyDataSetDelegate respondsToSelector:@selector(emptyDataSetWillAppear:)]) &#123; [self.emptyDataSetDelegate emptyDataSetWillAppear:self]; &#125;&#125;- (void)dzn_didAppear &#123; if (self.emptyDataSetDelegate &amp;&amp; [self.emptyDataSetDelegate respondsToSelector:@selector(emptyDataSetDidAppear:)]) &#123; [self.emptyDataSetDelegate emptyDataSetDidAppear:self]; &#125;&#125;- (void)dzn_willDisappear &#123; if (self.emptyDataSetDelegate &amp;&amp; [self.emptyDataSetDelegate respondsToSelector:@selector(emptyDataSetWillDisappear:)]) &#123; [self.emptyDataSetDelegate emptyDataSetWillDisappear:self]; &#125;&#125;- (void)dzn_didDisappear &#123; if (self.emptyDataSetDelegate &amp;&amp; [self.emptyDataSetDelegate respondsToSelector:@selector(emptyDataSetDidDisappear:)]) &#123; [self.emptyDataSetDelegate emptyDataSetDidDisappear:self]; &#125;&#125;- (void)dzn_didTapContentView:(id)sender &#123; if (self.emptyDataSetDelegate &amp;&amp; [self.emptyDataSetDelegate respondsToSelector:@selector(emptyDataSet:didTapView:)]) &#123; [self.emptyDataSetDelegate emptyDataSet:self didTapView:sender]; &#125;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wdeprecated-declarations" else if (self.emptyDataSetDelegate &amp;&amp; [self.emptyDataSetDelegate respondsToSelector:@selector(emptyDataSetDidTapView:)]) &#123; [self.emptyDataSetDelegate emptyDataSetDidTapView:self]; &#125;#pragma clang diagnostic pop&#125;- (void)dzn_didTapDataButton:(id)sender &#123; if (self.emptyDataSetDelegate &amp;&amp; [self.emptyDataSetDelegate respondsToSelector:@selector(emptyDataSet:didTapButton:)]) &#123; [self.emptyDataSetDelegate emptyDataSet:self didTapButton:sender]; &#125;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wdeprecated-declarations" else if (self.emptyDataSetDelegate &amp;&amp; [self.emptyDataSetDelegate respondsToSelector:@selector(emptyDataSetDidTapButton:)]) &#123; [self.emptyDataSetDelegate emptyDataSetDidTapButton:self]; &#125;#pragma clang diagnostic pop&#125; 以上这些方法，均是将代理协议方法封装成私有方法，当且仅当代理协议方法被实现的前提下，这些私有方法才会生效。 关于pragma clang diagnostic，是忽略系统编译警告。可以参考这篇博文。http://nshipster.cn/clang-diagnostics/ #pragma mark - Reload APIs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#pragma mark - Reload APIs (Public)- (void)reloadEmptyDataSet &#123; [self dzn_reloadEmptyDataSet];&#125;#pragma mark - Reload APIs (Private)- (void)dzn_reloadEmptyDataSet &#123; if (![self dzn_canDisplay]) &#123; return; &#125; if ([self dzn_shouldDisplay] &amp;&amp; [self dzn_itemsCount] == 0) &#123; // 通知该空白视图即将出现 [self dzn_willAppear]; DZNEmptyDataSetView *view = self.emptyDataSetView; if (!view.superview) &#123; // Send the view all the way to the back, in case a header and/or footer is present, as well as for sectionHeaders or any other content if (([self isKindOfClass:[UITableView class]] || [self isKindOfClass:[UICollectionView class]]) &amp;&amp; self.subviews.count &gt; 1) &#123; [self insertSubview:view atIndex:0]; &#125; else &#123; [self addSubview:view]; &#125; &#125; // 重新设置视图元素 [view prepareForReuse]; UIView *customView = [self dzn_customView]; // 判断是否存在自定义视图 if (customView) &#123; view.customView = customView; &#125; else &#123; //系统默认初始化配置 &#125; //..一些其它相关配置，包括布局，偏移和界面动画等。 // 通知该空白视图已经初始化完成。 [self dzn_didAppear]; &#125; else if (self.isEmptyDataSetVisible) &#123; [self dzn_invalidate]; &#125;&#125;- (void)dzn_invalidate &#123; // 通知该视图即将消失 [self dzn_willDisappear]; if (self.emptyDataSetView) &#123; [self.emptyDataSetView prepareForReuse]; [self.emptyDataSetView removeFromSuperview]; [self setEmptyDataSetView:nil]; &#125; self.scrollEnabled = YES; // 通知该视图已经消失 [self dzn_didDisappear];&#125; dzn_reloadEmptyDataSet 方法，通过判断当前是否存在自定义视图，若有则替换为自定义的View，否则则根据上述的配置私有方法对视图进行配置。 dzn_invalidate 方法则是在视图消失的时候，对父视图进行重新设置，以及移除该空白界面的数据源和子视图。 #pragma mark - Method Swizzling1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283static NSMutableDictionary *_impLookupTable;static NSString *const DZNSwizzleInfoPointerKey = @"pointer";static NSString *const DZNSwizzleInfoOwnerKey = @"owner";static NSString *const DZNSwizzleInfoSelectorKey = @"selector";void dzn_original_implementation(id self, SEL _cmd) &#123; // 从查找表获取原始实现 NSString *key = dzn_implementationKey(self, _cmd); NSDictionary *swizzleInfo = [_impLookupTable objectForKey:key]; NSValue *impValue = [swizzleInfo valueForKey:DZNSwizzleInfoPointerKey]; IMP impPointer = [impValue pointerValue]; //然后注入额外的实现重新加载空数据集 //在调用原始实现之前，确实按时更新“isEmptyDataSetVisible”标志。 [self dzn_reloadEmptyDataSet]; // 如果找到，调用原始实现 if (impPointer) &#123; ((void(*)(id,SEL))impPointer)(self,_cmd); &#125;&#125;NSString *dzn_implementationKey(id target, SEL selector) &#123; if (!target || !selector) &#123; return nil; &#125; Class baseClass; if ([target isKindOfClass:[UITableView class]]) baseClass = [UITableView class]; else if ([target isKindOfClass:[UICollectionView class]]) baseClass = [UICollectionView class]; else if ([target isKindOfClass:[UIScrollView class]]) baseClass = [UIScrollView class]; else return nil; NSString *className = NSStringFromClass([baseClass class]); NSString *selectorName = NSStringFromSelector(selector); return [NSString stringWithFormat:@"%@_%@",className,selectorName];&#125;- (void)swizzleIfPossible:(SEL)selector &#123; // 检查目标是否响应selector if (![self respondsToSelector:selector]) &#123; return; &#125; // 创建查找表 if (!_impLookupTable) &#123; _impLookupTable = [[NSMutableDictionary alloc] initWithCapacity:2]; &#125; // 我们确保每个UITableView或UICollectionView的setImplementation方法，被调用一次。 for (NSDictionary *info in [_impLookupTable allValues]) &#123; Class class = [info objectForKey:DZNSwizzleInfoOwnerKey]; NSString *selectorName = [info objectForKey:DZNSwizzleInfoSelectorKey]; if ([selectorName isEqualToString:NSStringFromSelector(selector)]) &#123; if ([self isKindOfClass:class]) &#123; return; &#125; &#125; &#125; NSString *key = dzn_implementationKey(self, selector); NSValue *impValue = [[_impLookupTable objectForKey:key] valueForKey:DZNSwizzleInfoPointerKey]; // 如果这个类的实现已经存在，跳过！ if (impValue || !key) &#123; return; &#125; // 通过Swizzle注入额外的实现 Method method = class_getInstanceMethod([self class], selector); IMP dzn_newImplementation = method_setImplementation(method, (IMP)dzn_original_implementation); // 将新实现存储在查找表中 NSDictionary *swizzledInfo = @&#123;DZNSwizzleInfoOwnerKey: [self class], DZNSwizzleInfoSelectorKey: NSStringFromSelector(selector), DZNSwizzleInfoPointerKey: [NSValue valueWithPointer:dzn_newImplementation]&#125;; [_impLookupTable setObject:swizzledInfo forKey:key];&#125; 此处有一篇作者推荐的关于method swizzing技术的博文: The Right Way to Swizzle in Objective-C dzn_original_implementation方法用于调用原始实现方法 dzn_implementationKey方法获取交换方法的方法名，用过类名以及对应方法名进行封装，防止交换错方法，因为界面中可能存在多个需要空白视图的父视图reloadData方法，避免交换错误。这个设计细节值得学习。 swizzleIfPossible:(SEL)selector方法用于判断当前方法是否允许交换，比如父视图是否存在并且为约定的类型，以及是否调用了需要交换的方法。 值得着重注意的一个比较有意思的地方，也是我第一次看到这样的交换的地方，就是该方法中，通过一个字典作为一个查找表，确保当存在多个空白视图时，每个UITableView 或者 UICollectionView的原始方法只被交换了一次，避免了重复交换导致bug。这个细节处理应该是这个框架的精髓了！ #pragma mark - UIGestureRecognizerDelegate Methods12345678910111213141516171819202122- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer&#123; if ([gestureRecognizer.view isEqual:self.emptyDataSetView]) &#123; return [self dzn_isTouchAllowed]; &#125; return [super gestureRecognizerShouldBegin:gestureRecognizer];&#125;- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123; UIGestureRecognizer *tapGesture = self.emptyDataSetView.tapGesture; if ([gestureRecognizer isEqual:tapGesture] || [otherGestureRecognizer isEqual:tapGesture]) &#123; return YES; &#125; // defer to emptyDataSetDelegate's implementation if available if ( (self.emptyDataSetDelegate != (id)self) &amp;&amp; [self.emptyDataSetDelegate respondsToSelector:@selector(gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:)]) &#123; return [(id)self.emptyDataSetDelegate gestureRecognizer:gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:otherGestureRecognizer]; &#125; return NO;&#125; 该方法设置该空白视图的响应手势，通过返回协议方法中定义的手势响应回调。 最后通过源码的分析，我也解决了开头提出的问题。该框架通过分类扩展，以及代理协议的方式，达到了监听视图是否该在没有数据源的情况下显示空白视图。不过个人觉得，框架中仍有一些代码可以写得稍微精简些，比如一些判断可以封装一下。这样会少些一些重复的代码。哈哈，仅仅是吹毛求疵罢了。总体这个框架还是非常赞的，使用该框架，也完善了一些用户体验，值得推荐。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[『Hexo』使用Hexo搭建GitHub博客]]></title>
      <url>%2F2016%2F12%2F01%2F%E3%80%8EHexo%E3%80%8F%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[『Hexo』使用Hexo搭建GitHub博客 前言：​ 谈起这个博客的由来，真的挺不容易的。一年前兴奋地买了域名，后来因为很多东西都不具备实现这个模版博客的能力，遂搁置了域名，选择了简书。有点笨，这一次也折腾了两三个晚上，总算把它搭建起来了。 环境准备 git搭建 ：git教程 node.js : node.js download git主要用于将代码同步到GitHub平台，node.js主要用到了npm这个包管理器，方便我们快速搭建Hexo环境。 个人的主机环境为：MacOS 注册Github 我们的主要目的就是把本地的静态网站托管到GitHub这个平台上。 Tips: 我遇到的一个坑就是，我用的是QQ邮箱注册，GitHub验证邮件被拦截了，貌似163邮箱也会拦截。一定要验证邮箱，否则即使你博客搭建好了，托管到GitHub上面，也会一直404无法打开。 Quick Start 安装Hexo 1sudo npm install hexo-cli -g Hexo官方文档：Hexo 利用Hexo初始化一个博客文件夹 1hexo init [文件夹] npm install 命令用来安装模块到node_modules目录。 12cd [文件夹] //进入到博客文件夹npm install //利用npm install命令安装模块node_modules 关于npm的详细使用，参照文档，或者npm 模块安装机制简介。 至此，一个博客已经搭建好了，但是我们还没办法看到它。接下来就利用Hexo命令来启动我们的博客。 12hexo g //利用Hexo 生成静态页面hexo s //启动本地服务 你一定迫不及待想看看这个东西给你带来了什么样的惊喜。打开浏览器，http://localhost:4000，你就可以看到一个模版博客已经出现在你面前了，虽然这不是你最终想要的，不过也算是让我们眼前一亮。 命令倒是执行了几个了，但是我们不知道它到底做了些什么。先来看看吧。 1ls //查看文件目录， 当然一些隐藏文件无法查看， 没关系，ls -al即可。 暂时忽略其他文件是干什么的，先看看 _config.yml，这是我博客的设置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Shawenlx #博客标题subtitle: #副标题description: I love code and share. #个人描述author: Liuxi #作者名language: en #站点语言，如果是中文，把en替换成zh-CNtimezone: #同步时区# URLurl: /root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directory 文件目录对应生成的文件夹目录source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: #代码高亮 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map: categoriestag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination ## Set per_page to 0 to disable pagination 设置分页per_page: 10pagination_dir: page# Extensionstheme: next #主题模版，搜索 ./themes 文件夹下的主题，此处我用的NexT模版# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/shawenlx/shawenlx.github.io.git branch: master Tips: 当我们着手修改这个文件的时候，字段名以及:后面，切记一定要加一个空格！我一开始也遇到这个问题，执行hexo g命令的时候，就会报错提示我_config.yml文件无法解析。 将博客托管到Github平台 创建一个GitHub仓库，new repository 在 Repository name 栏中，输入 your user name.github.io，譬如我的GitHub用户名是shawenlx，所以就建立工程名为：shawenlx.github.io 配置好本地的SSH Key。 拥有了个人的GitHub Pages后，再回到Hexo的_config.yml文件, 参照我的配置保存即可。 1234deploy: type: git repo: https://github.com/shawenlx/shawenlx.github.io.git branch: master 最后利用hexo命令，将博客推送到Github上。 12hexo clean #推送前，先清除下本地数据库，防止缓存导致上传不成功hexo d -g #利用这个组合命令，将博客上传到github上。 当你打开浏览器，输入your_user_name.github.io，就可以看到你托管到平台上的数据了。 关于博客主题模版 网上有各种各样的模版，我用的NexT, 参照官方文档进行配置就可以了。目前博客还在完善，特此记录本博客的搭建经历。 关于管理博客内容 参照Hexo官方文档 最后以后简书会同步更新这个博客的内容。 复习本博客链接：shawenlx.github.io]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UITableView+FDTemplateLayoutCell 源码探究]]></title>
      <url>%2F2016%2F11%2F27%2FUITableView-FDTemplateLayoutCell-%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6%2F</url>
      <content type="text"><![CDATA[UITableView+FDTemplateLayoutCell 源码探究 在我们日常的业务中，常常伴随大量的UITableView，然而动态地计算Cell的高度常常困扰着我。自从使用了这个组件之后，一切都变得没那么复杂。所以深入学习下这个框架的组件的实现原理。 框架地址：https://github.com/forkingdog/UITableView-FDTemplateLayoutCell 代码文件目录12345678- UITableView+FDIndexPathHeightCache.h- UITableView+FDIndexPathHeightCache.m- UITableView+FDKeyedHeightCache.h- UITableView+FDKeyedHeightCache.m- UITableView+FDTemplateLayoutCell.h- UITableView+FDTemplateLayoutCell.m- UITableView+FDTemplateLayoutCellDebug.h- UITableView+FDTemplateLayoutCellDebug.m 首先，介绍一下这几个类的基本功能，再层层推进，逐一分析。 1234- UITableView+FDIndexPathHeightCache，主要负责cell通过NSIndexPath进行缓存高度的功能- UITableView+FDKeyedHeightCache，主要负责cell通过key值进行缓存高度的功能- UITableView+FDTemplateLayoutCell，提供接口方法方便用户定义cell的数据源，以及帮助我们计算cell的高度- UITableView+FDTemplateLayoutCellDebug，提供一些Debug打印信息 关于这个框架，坦白说，从代码中看，作者无疑秀了一波runtime底层的功底，让我这种小白起初一脸懵逼。自然我得换种思路来解读这个框架，那就是从字数最少的类入手吧。 UITableView+FDTemplateLayoutCellDebug123456789@interface UITableView (FDTemplateLayoutCellDebug)//设置Debug模式是否打开@property (nonatomic, assign) BOOL fd_debugLogEnabled;//通过该方法，传递NSLog打印对应的Debug信息- (void)fd_debugLog:(NSString *)message;@end 1234567891011121314151617@implementation UITableView (FDTemplateLayoutCellDebug)- (BOOL)fd_debugLogEnabled &#123; return [objc_getAssociatedObject(self, _cmd) boolValue];&#125;- (void)setFd_debugLogEnabled:(BOOL)debugLogEnabled &#123; objc_setAssociatedObject(self, @selector(fd_debugLogEnabled), @(debugLogEnabled), OBJC_ASSOCIATION_RETAIN);&#125;- (void)fd_debugLog:(NSString *)message &#123; if (self.fd_debugLogEnabled) &#123; NSLog(@"** FDTemplateLayoutCell ** %@", message); &#125;&#125;@end 在分类中，如果要声明属性，可以通过使用关联度对象( AssociatedObject ), 通过objc_setAssociatedObject() 添加属性，objc_getAssociatedObject() 获取属性。实际上，相当于在运行时系统中动态地在内存中开辟一块空间，存储debugLogEnabled这个BOOL变量，类似懒加载的方式，通过runtime实现setter &amp; getter方法。 关于runtime的知识点，推荐这篇博客:http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/ UITableView+FDKeyedHeightCache1234567891011121314151617181920212223#import &lt;UIKit/UIKit.h&gt;@interface FDKeyedHeightCache : NSObject//判断缓存中是否存在key为值的缓存高度- (BOOL)existsHeightForKey:(id&lt;NSCopying&gt;)key;//对指定key的cell设置高度为height- (void)cacheHeight:(CGFloat)height byKey:(id&lt;NSCopying&gt;)key;//从缓存中获取对应key的cell的高度height值- (CGFloat)heightForKey:(id&lt;NSCopying&gt;)key;//从缓存中删除指定key的cell的值- (void)invalidateHeightForKey:(id&lt;NSCopying&gt;)key;//移除缓存中所有的cell的高度缓存值- (void)invalidateAllHeightCache;@end@interface UITableView (FDKeyedHeightCache)@property (nonatomic, strong, readonly) FDKeyedHeightCache *fd_keyedHeightCache;@end 先来看看FDKeyedHeightCache类中声明的属性 123@property (nonatomic, strong) NSMutableDictionary&lt;id&lt;NSCopying&gt;, NSNumber *&gt; *mutableHeightsByKeyForPortrait;@property (nonatomic, strong) NSMutableDictionary&lt;id&lt;NSCopying&gt;, NSNumber *&gt; *mutableHeightsByKeyForLandscape; 不难看出，这是两个指定泛型的可变字典。 mutableHeightsByKeyForPortrait : 用于缓存设备竖直放置时，对应key的cell的高度值。 mutableHeightsByKeyForLandscape : 用于缓存设备横向放置时，对应key的cell的高度值。 FDKeyedHeightCache中的接口方法 1234567891011121314151617181920212223242526- (BOOL)existsHeightForKey:(id&lt;NSCopying&gt;)key &#123; NSNumber *number = self.mutableHeightsByKeyForCurrentOrientation[key]; return number &amp;&amp; ![number isEqualToNumber:@-1];&#125;- (void)cacheHeight:(CGFloat)height byKey:(id&lt;NSCopying&gt;)key &#123; self.mutableHeightsByKeyForCurrentOrientation[key] = @(height);&#125;- (CGFloat)heightForKey:(id&lt;NSCopying&gt;)key &#123;#if CGFLOAT_IS_DOUBLE return [self.mutableHeightsByKeyForCurrentOrientation[key] doubleValue];#else return [self.mutableHeightsByKeyForCurrentOrientation[key] floatValue];#endif&#125;- (void)invalidateHeightForKey:(id&lt;NSCopying&gt;)key &#123; [self.mutableHeightsByKeyForPortrait removeObjectForKey:key]; [self.mutableHeightsByKeyForLandscape removeObjectForKey:key];&#125;- (void)invalidateAllHeightCache &#123; [self.mutableHeightsByKeyForPortrait removeAllObjects]; [self.mutableHeightsByKeyForLandscape removeAllObjects];&#125; 这些方法并不晦涩，看到这里，大家不禁会问，self.mutableHeightsByKeyForCurrentOrientation从何而来，这也是我觉得这个类中，细节处理比较好的地方，由于此处考虑到缓存的高度区别了设备方向，所以框架作者，通过一个getter方法来获取对应的存放高度的字典。 123- (NSMutableDictionary&lt;id&lt;NSCopying&gt;, NSNumber *&gt; *)mutableHeightsByKeyForCurrentOrientation &#123; return UIDeviceOrientationIsPortrait([UIDevice currentDevice].orientation) ? self.mutableHeightsByKeyForPortrait: self.mutableHeightsByKeyForLandscape;&#125; 根据UIDeviceOrientationIsPortrait()函数，传入当前设备的放置方向（[UIDevice currentDevice].orientation ）进行判断。从而便可以通过属性简洁判断需要从那个字典中取值了。 UITableView+FDIndexPathHeightCache1234567891011121314151617181920212223@interface FDIndexPathHeightCache : NSObject// 如果您使用索引路径获取高度缓存，则自动启用@property (nonatomic, assign) BOOL automaticallyInvalidateEnabled;// Height cache- (BOOL)existsHeightAtIndexPath:(NSIndexPath *)indexPath;- (void)cacheHeight:(CGFloat)height byIndexPath:(NSIndexPath *)indexPath;- (CGFloat)heightForIndexPath:(NSIndexPath *)indexPath;- (void)invalidateHeightAtIndexPath:(NSIndexPath *)indexPath;- (void)invalidateAllHeightCache;@end@interface UITableView (FDIndexPathHeightCache)@property (nonatomic, strong, readonly) FDIndexPathHeightCache *fd_indexPathHeightCache;@end@interface UITableView (FDIndexPathHeightCacheInvalidation)/// 当你不想通过删除缓存中的高度来刷新数据源重新计算时，可以调用这个方法。/// 该方法中用过runtime重写了tableView中修改cell的一些方法，例如插入cell，删除cell，移动cell，以及reloadData方法。- (void)fd_reloadDataWithoutInvalidateIndexPathHeightCache;@end 首先看看FDIndexPathHeightCache中设置的属性 123456typedef NSMutableArray&lt;NSMutableArray&lt;NSNumber *&gt; *&gt; FDIndexPathHeightsBySection;@interface FDIndexPathHeightCache ()@property (nonatomic, strong) FDIndexPathHeightsBySection *heightsBySectionForPortrait;@property (nonatomic, strong) FDIndexPathHeightsBySection *heightsBySectionForLandscape;@end 通过前面key的高度缓存分析，不难猜出这几个属性是干什么的。 由于通过NSIndexPath获取高度缓存，NSIndexPath对应section, 以及indexPath。FDIndexPathHeightsBySection这个数组，通过数组嵌套字典的数据结构来存储，不同的section组中对应的cell的高度缓存。 FDIndexPathHeightCache中的方法 由于头文件声明的几个接口方法，与FDKeyedHeightCache中的思路类似，就不再费口舌了，大家翻看源码便一目了然。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (void)enumerateAllOrientationsUsingBlock:(void (^)(FDIndexPathHeightsBySection *heightsBySection))block &#123; block(self.heightsBySectionForPortrait); block(self.heightsBySectionForLandscape);&#125;- (void)invalidateHeightAtIndexPath:(NSIndexPath *)indexPath &#123; [self buildCachesAtIndexPathsIfNeeded:@[indexPath]]; [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection &#123; heightsBySection[indexPath.section][indexPath.row] = @-1; &#125;];&#125;- (void)invalidateAllHeightCache &#123; [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123; [heightsBySection removeAllObjects]; &#125;];&#125;- (void)buildCachesAtIndexPathsIfNeeded:(NSArray *)indexPaths &#123; // Build every section array or row array which is smaller than given index path. [indexPaths enumerateObjectsUsingBlock:^(NSIndexPath *indexPath, NSUInteger idx, BOOL *stop) &#123; [self buildSectionsIfNeeded:indexPath.section]; [self buildRowsIfNeeded:indexPath.row inExistSection:indexPath.section]; &#125;];&#125;- (void)buildSectionsIfNeeded:(NSInteger)targetSection &#123; [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123; for (NSInteger section = 0; section &lt;= targetSection; ++section) &#123; if (section &gt;= heightsBySection.count) &#123; heightsBySection[section] = [NSMutableArray array]; &#125; &#125; &#125;];&#125;- (void)buildRowsIfNeeded:(NSInteger)targetRow inExistSection:(NSInteger)section &#123; [self enumerateAllOrientationsUsingBlock:^(FDIndexPathHeightsBySection *heightsBySection) &#123; NSMutableArray&lt;NSNumber *&gt; *heightsByRow = heightsBySection[section]; for (NSInteger row = 0; row &lt;= targetRow; ++row) &#123; if (row &gt;= heightsByRow.count) &#123; heightsByRow[row] = @-1; &#125; &#125; &#125;];&#125; 这几个封装的方法，主要一点就是通过block来回调，判断删除NSIndexPath对应的cell高度缓存。 在这个类中，最核心的莫过于UITableView (FDIndexPathHeightCacheInvalidation) 这个分类的实现细节，废话少说，继续看代码。 1234567//我们只是转发主调用，在崩溃报告中，最顶层的方法在堆栈可能存在FD，//但它真的不是我们的错误，你应该检查你的表视图的数据源和//重新加载时显示单元格不匹配。static void __FD_TEMPLATE_LAYOUT_CELL_PRIMARY_CALL_IF_CRASH_NOT_OUR_BUG__(void (^callout)(void)) &#123; callout();&#125;#define FDPrimaryCall(...) do &#123;__FD_TEMPLATE_LAYOUT_CELL_PRIMARY_CALL_IF_CRASH_NOT_OUR_BUG__(^&#123;__VA_ARGS__&#125;);&#125; while(0) 调用的接口方法 123- (void)fd_reloadDataWithoutInvalidateIndexPathHeightCache &#123; FDPrimaryCall([self fd_reloadData];);&#125; 这个方法，主要调用的是［self fd_reloadData］，看到这里的时候，我们的第一反应应该是此处通过runtime 交换了系统方法的实现。这是一种动态的拦截技巧，也算是基础的runtime知识了，懵逼的小伙伴可以认真阅读下前面提到的关于runtime的大牛博文。 既然如此，先来看看作者重写了哪些系统的方法吧。 12345678910111213141516171819202122+ (void)load &#123; // All methods that trigger height cache's invalidation SEL selectors[] = &#123; @selector(reloadData), @selector(insertSections:withRowAnimation:), @selector(deleteSections:withRowAnimation:), @selector(reloadSections:withRowAnimation:), @selector(moveSection:toSection:), @selector(insertRowsAtIndexPaths:withRowAnimation:), @selector(deleteRowsAtIndexPaths:withRowAnimation:), @selector(reloadRowsAtIndexPaths:withRowAnimation:), @selector(moveRowAtIndexPath:toIndexPath:) &#125;; for (NSUInteger index = 0; index &lt; sizeof(selectors) / sizeof(SEL); ++index) &#123; SEL originalSelector = selectors[index]; SEL swizzledSelector = NSSelectorFromString([@"fd_" stringByAppendingString:NSStringFromSelector(originalSelector)]); Method originalMethod = class_getInstanceMethod(self, originalSelector); Method swizzledMethod = class_getInstanceMethod(self, swizzledSelector); method_exchangeImplementations(originalMethod, swizzledMethod); &#125;&#125; 通过method_exchangeImplementations() C函数， 将重写的方法，一一交换成重写的方法。 在这些fd_方法中的实现细节中，需要注意的一点就是，如果对应的fd_indexPathHeightCache设置了automaticallyInvalidateEnabled属性为YES时，对应的方法对高度缓存做相应的处理，重新更新fd_indexPathHeightCache中存储的高度缓存。 当第一次reloadData，或者cell的行数发生变化（增减行，section) ，会先在tableview不处于滚动状态的时候异步计算那些没有被计算过的cell的高度，做预缓存，这个想法非常赞。 使用者需要小心，这些调用是异步的, tableview delegate有可能会在预缓存计算的时候不存在了，导致程序崩溃，所以使用者在tableview需要析构的时候，在对应的tableview controller的dealloc中讲self.tableview.delegate = nil；，确保delegate后续不会是一个野指针。 UITableView+FDTemplateLayoutCell至此，我们已经分析了几个子类的实现逻辑，唯一剩下一个分类，也是我们使用这个框架的入口 FDTemplateLayoutCell分类。全面了解这个组件近在咫尺。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@interface UITableView (FDTemplateLayoutCell)/* 为给定的重用标识符访问内部模板布局单元格。 * 一般来说，你不需要知道这些模板布局单元格。 * @param identifier重用必须注册的单元格的标识符。*/ - (__kindof UITableViewCell *)fd_templateCellForReuseIdentifier:(NSString *)identifier;/* 返回由重用标识符指定并配置的类型的单元格的高度, 并通过block来配置。 * 单元格将被放置在固定宽度，垂直扩展的基础上，相对于其动态内容，使用自动布局。 * 因此，这些必要的单元被设置为自适应，即其内容总是确定它的宽度给定的宽度等于tableview的宽度。 * @param identifier用于检索和维护模板的字符串标识符cell通过系统方法 * '- dequeueReusableCellWithIdentifier：' * @param configuration用于配置和提供内容的可选块到模板单元格。 * 配置应该是最小的滚动性能足以计算单元格的高度。*/- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier configuration:(void (^)(id cell))configuration;/* 计算的高度将通过其索引路径进行高速缓存，当需要时返回高速缓存的高度，因此，可以节省大量额外的高度计算。 * 无需担心数据源更改时使缓存高度无效，它将在调用“-reloadData”或任何触发方法时自动完成UITableView的重新加载。 * @param indexPath此单元格的高度缓存所属的位置。*/- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByIndexPath:(NSIndexPath *)indexPath configuration:(void (^)(id cell))configuration;/* 此方法通过模型实体的标识符缓存高度。 * 如果你的模型改变，调用“-invalidateHeightForKey:(id &lt;NSCopying&gt;)key”到无效缓存并重新计算，它比“cacheByIndexPath”方便得多。 * @param key model entity的标识符，其数据配置一个单元格。*/ - (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByKey:(id&lt;NSCopying&gt;)key configuration:(void (^)(id cell))configuration;@end@interface UITableView (FDTemplateLayoutHeaderFooterView)/* 返回在具有重用标识符的表视图中注册的Header或Footer视图的高度。 * 在调用“ - [UITableView registerNib / Class：forHeaderFooterViewReuseIdentifier]”之后使用它， * 与“-fd_heightForCellWithIdentifier：configuration：”相同。 * 它将调用“-sizeThatFits：” * UITableViewHeaderFooterView的子类不使用自动布局。*/ - (CGFloat)fd_heightForHeaderFooterViewWithIdentifier:(NSString *)identifier configuration:(void (^)(id headerFooterView))configuration;@end@interface UITableViewCell (FDTemplateLayoutCell)/* 指示这是仅用于计算的模板布局单元格。 * 当配置单元格时，如果有非UI的副作用，你可能需要这个。 * 类似: * - (void)configureCell:(FooCell *)cell atIndexPath:(NSIndexPath *)indexPath &#123; * cell.entity = [self entityAtIndexPath:indexPath]; * if (!cell.fd_isTemplateLayoutCell) &#123; * [self notifySomething]; // non-UI side effects * &#125; * &#125;*/@property (nonatomic, assign) BOOL fd_isTemplateLayoutCell;/* 启用以强制此模板布局单元格使用“框架布局”而不是“自动布局”， * 并且通过调用“-sizeThatFits：”来询问单元格的高度，所以你必须重写这个方法。 * 仅当要手动控制此模板布局单元格的高度时才使用此属性 * 计算模式，默认为NO。*/@property (nonatomic, assign) BOOL fd_enforceFrameLayout;@end 先来看看我们平时开发中最频繁调用的两个方法 (CGFloat)fd_heightForCellWithIdentifier:(NSString )identifier cacheByIndexPath:(NSIndexPath )indexPath configuration:(void (^)(id cell))configuration; (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByKey:(id)key configuration:(void (^)(id cell))configuration; 12345678910111213141516171819202122232425262728293031- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByIndexPath:(NSIndexPath *)indexPath configuration:(void (^)(id cell))configuration &#123; if (!identifier || !indexPath) &#123; return 0; &#125; // Hit cache if ([self.fd_indexPathHeightCache existsHeightAtIndexPath:indexPath]) &#123; return [self.fd_indexPathHeightCache heightForIndexPath:indexPath]; &#125; CGFloat height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration]; [self.fd_indexPathHeightCache cacheHeight:height byIndexPath:indexPath]; return height;&#125;- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier cacheByKey:(id&lt;NSCopying&gt;)key configuration:(void (^)(id cell))configuration &#123; if (!identifier || !key) &#123; return 0; &#125; // Hit cache if ([self.fd_keyedHeightCache existsHeightForKey:key]) &#123; CGFloat cachedHeight = [self.fd_keyedHeightCache heightForKey:key]; return cachedHeight; &#125; CGFloat height = [self fd_heightForCellWithIdentifier:identifier configuration:configuration]; [self.fd_keyedHeightCache cacheHeight:height byKey:key]; return height;&#125; 这两个方法，分别是对cell通过NSIndexPath 或者 key值 进行高度缓存，读取高度的时候，先从缓存cache中读取，如果缓存中没有，在通过[self fd_heightForCellWithIdentifier:identifier configuration:configuration]方法进行计算高度并加入缓存中。 12345678910111213141516- (CGFloat)fd_heightForCellWithIdentifier:(NSString *)identifier configuration:(void (^)(id cell))configuration &#123; if (!identifier) &#123; return 0; &#125; UITableViewCell *templateLayoutCell = [self fd_templateCellForReuseIdentifier:identifier]; //手动调用以确保与实际单元格的一致行为。 （显示在屏幕上） [templateLayoutCell prepareForReuse]; if (configuration) &#123; configuration(templateLayoutCell); &#125; return [self fd_systemFittingHeightForConfiguratedCell:templateLayoutCell];&#125; 通过blocks进行配置并计算cell的高度，主要通过[self fd_templateCellForReuseIdentifier:identifier]方法创建一个UITableViewCell的实例templateLayoutCell，最后再把templateLayoutCell放入[self fd_systemFittingHeightForConfiguratedCell:templateLayoutCell]中进行计算返回高度。 12345678910111213141516171819202122- (__kindof UITableViewCell *)fd_templateCellForReuseIdentifier:(NSString *)identifier &#123; NSAssert(identifier.length &gt; 0, @"Expect a valid identifier - %@", identifier); NSMutableDictionary&lt;NSString *, UITableViewCell *&gt; *templateCellsByIdentifiers = objc_getAssociatedObject(self, _cmd); if (!templateCellsByIdentifiers) &#123; templateCellsByIdentifiers = @&#123;&#125;.mutableCopy; objc_setAssociatedObject(self, _cmd, templateCellsByIdentifiers, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; UITableViewCell *templateCell = templateCellsByIdentifiers[identifier]; if (!templateCell) &#123; templateCell = [self dequeueReusableCellWithIdentifier:identifier]; NSAssert(templateCell != nil, @"Cell must be registered to table view for identifier - %@", identifier); templateCell.fd_isTemplateLayoutCell = YES; templateCell.contentView.translatesAutoresizingMaskIntoConstraints = NO; templateCellsByIdentifiers[identifier] = templateCell; [self fd_debugLog:[NSString stringWithFormat:@"layout cell created - %@", identifier]]; &#125; return templateCell;&#125; 将所有创建的templateCell放置在一个字典templateCellsByIdentifiers中，并通过runtime将其加入内存中作为属性，实际上，templateCell 也是通过identifier在复用队列中获取复用的。所以，cell在使用前，应先注册为cell的复用对象。 最后调用的[self fd_systemFittingHeightForConfiguratedCell:templateLayoutCell]进行高度计算。当然也是最关键的一个操作，既然这是一个高度计算的框架，那么计算的步骤当然是重中之重。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (CGFloat)fd_systemFittingHeightForConfiguratedCell:(UITableViewCell *)cell &#123; CGFloat contentViewWidth = CGRectGetWidth(self.frame); if (cell.accessoryView) &#123; //如果有定制accessoryView，则去除这个宽度 contentViewWidth -= 16 + CGRectGetWidth(cell.accessoryView.frame); &#125; else &#123; //如果有系统accessoryView展示，则去除对应的宽度。 static const CGFloat systemAccessoryWidths[] = &#123; [UITableViewCellAccessoryNone] = 0, [UITableViewCellAccessoryDisclosureIndicator] = 34, [UITableViewCellAccessoryDetailDisclosureButton] = 68, [UITableViewCellAccessoryCheckmark] = 40, [UITableViewCellAccessoryDetailButton] = 48 &#125;; contentViewWidth -= systemAccessoryWidths[cell.accessoryType]; &#125; CGFloat fittingHeight = 0; if (!cell.fd_enforceFrameLayout &amp;&amp; contentViewWidth &gt; 0) &#123; //如果是自动布局，则将contentView的宽度约束添加进去。 //这样做的目的是让UILabel之类的内容可能多行的控件适应这个宽度折行（当然前提是我们已经设置好了这些控件的布局约束）。然后调用systemLayoutSizeFittingSize来计算高度。 //最后移除刚才临时添加的contentView宽度约束。 NSLayoutConstraint *widthFenceConstraint = [NSLayoutConstraint constraintWithItem:cell.contentView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:contentViewWidth]; [cell.contentView addConstraint:widthFenceConstraint]; fittingHeight = [cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height; [cell.contentView removeConstraint:widthFenceConstraint]; &#125; if (fittingHeight == 0) &#123; // 尝试调用 '- sizeThatFits:'进行高度计算. // 注意：配件高度不应包括分隔线视图高度。 fittingHeight = [cell sizeThatFits:CGSizeMake(contentViewWidth, 0)].height; &#125; // 进行完前面的逻辑后高度如果仍然为0，则使用默认行高44 if (fittingHeight == 0) &#123; fittingHeight = 44; &#125; // 添加一像素作为tableView分割线高度。 if (self.separatorStyle != UITableViewCellSeparatorStyleNone) &#123; fittingHeight += 1.0 / [UIScreen mainScreen].scale; &#125; return fittingHeight;&#125; 至此，就大致将这个框架分析的差不多了，源码中，对类的实例化均为采用runtime添加AssociatedObject的方式。就不做解释了。 最后 赏花不忘种花人，把作者关于这个框架优秀的性能分析复习下。 地址：http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/ ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NSOperation：初识]]></title>
      <url>%2F2016%2F08%2F09%2FNSOperation%EF%BC%9A%E5%88%9D%E8%AF%86%2F</url>
      <content type="text"><![CDATA[NSOperation的简介NSOperation的抽象程度高于NSThread，它是苹果对线程的一个面向对象封装。NSOperation表示一个独立的计算单元，作为一个抽象类，你需要实例化他的子类 : NSInvocationOperation / NSBlockOperation 来进行具体操作。实例化之后，调用start方法或者加入到一个NSOperationQueue 操作队列中，就可以开始执行。 NSOperation的使用 启动NSInvocationOperation 123// 如果直接调用operation的start方法，是在主线程上运行，不会开启新的线程NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(threadLoadImage:) object:imageView];[operation start]; 使用NSOperationQueue管理NSOperation并开启一个异步线程 12// 定义操作队列属性@property (strong, nonatomic) NSOperationQueue *queue; 12// 实例化操作队列self.queue = [[NSOperationQueue alloc] init]; 12// 初始化一个NSInvocationOperationNSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(threadLoadImage:) object:imageView]; 12// 将NSInvocationOperation添加到队列，一添加到队列，就会开启新线程执行任务，不可以同时使用start[self.queue addOperation:operation]; 使用NSOperationQueue管理并NSBlockOperation开启一个线程 更偏向于使用NSBlockOperation，原因在于通过使用代码块会更方便一些，本质上和NSInvocationOperation没有区别。 1234// 初始化一个NSBlockOperationNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123; // 异步操作 [self operationLoadImage:imageView];&#125;];// 添加操作到队列中[self.queue addOperation:operation]; 在主线程中执行操作 12345//可通过该＋方法 获取系统主线程，通常我们刷新UI界面进行绘制的时候，必须在主线程下完成。+ (NSOperationQueue *)mainQueue NS_AVAILABLE(10_6, 4_0);//该＋号方法可以获取当前使用线程+ (nullable NSOperationQueue *)currentQueue NS_AVAILABLE(10_6, 4_0); 1234// 在主线程队列上更新UI[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; [imageView setImage:image];&#125;]; 通过 addDependency：添加线程之间的依赖关系 Tip: 直接在队列中添加操作会并发执行，执行顺序是系统调用决定的，在特定的时候我们需要控制操作的执行顺序，就会使用到addDependency操作。addDependency: 是NSOperation的成员方法，调用该方法的NSOperation对象将在参数执行完成之后执行。需要先添加依赖关系，再将操作添加到队列中。 12345678910111213141516171819202122// 初始化三个块操作 NSBlockOperation *op1 =[NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"下载 %@", [NSThread currentThread]); &#125;]; NSBlockOperation *op2 =[NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"美化 %@", [NSThread currentThread]); &#125;]; NSBlockOperation *op3 =[NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"更新 %@", [NSThread currentThread]); &#125;]; // 通过添加依赖可以控制线程执行顺序，依赖关系可以多重依赖 // 注意：不要建立循环依赖，会造成死锁 [op2 addDependency:op1]; [op3 addDependency:op2]; // 直接加到队列里面会并发执行，谁先先后是系统调用决定 [self.operationQueue addOperation:op3]; [self.operationQueue addOperation:op1]; [self.operationQueue addOperation:op2]; 控制线程并发数 12// 并发的线程越多越耗资源，队列可以设置同时并发线程的数量，来进行控制self.queue.maxConcurrentOperationCount = 2; 取消线程操作 NSOperation里有一系列的属性用来标明自身状态的，isReady → isExecuting →isFinish。线程start后并不是立即执行，而是进入一个就绪的状态（isReady），由系统调度执行。 12//有时可能需要进行取消操作，可以调用– (void)cancel; 来停止一些还未执行的不必要的线程。[operation cancel]; 为NSOperation添加完成代码块 123operation.completionBlock = ^&#123; NSLog(@"completion!");&#125;; NSOperation的优先级 123456789101112131415161718//同NSThread一样，NSOperation可以通过threadPriority属性来指定优先级。//但是在IOS8，线程这个概念已经被苹果框架系统性的忽略了，threadPriority已由NSQualityOfService属性替代.typedef NS_ENUM(NSInteger, NSQualityOfService) &#123; /* 和图形处理相关的任务，比如滚动和动画 */ NSQualityOfServiceUserInteractive = 0x21, /* 用户请求的任务，但是不需要精确到毫秒级。例如如果用户请求打开电子邮件App来查看邮件 */ NSQualityOfServiceUserInitiated = 0x19, /* 周期性的用户请求任务。比如，电子邮件App可能被设置成每5分钟自动检测新邮件。但是在系统资源极度匮乏的时候，将这个周期性的任务推迟几分钟也没有大碍*/ NSQualityOfServiceUtility = 0x11, /* 后台任务，对这些任务用户可能并不会察觉，比如电子邮件App对邮件进行索引以方便搜索 */ NSQualityOfServiceBackground = 0x09, /* 默认的优先级 */ NSQualityOfServiceDefault = -1&#125; NS_ENUM_AVAILABLE(10_10, 8_0); NSOperation优势 NSOperation方便控制线程执行顺序 使用NSBlockOperation可以使用块代码，不必单写线程方法，便于传递多个参数 可以控制线程并发数，有效地对线程进行控制 可以添加线程完成代码块，执行需要的操作 对比GCD 和 NSOperation虽然GCD已经成为流行， 但是在某些框架中，例如AFNetworking还是使用的NSOperation来完成线程相关的操作，除了使用框架的NSInvocationOperation / NSBlockOperation 来处理线程操作，你也可以通过自定义集成来完成你需要的操作。 关于NSOperation博客的传送门http://www.cnblogs.com/kenshincui/p/3983982.html#NSOperationhttp://nshipster.cn/ios8/http://nshipster.cn/nsoperation/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于链表的一些逻辑思维]]></title>
      <url>%2F2016%2F06%2F09%2F%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E9%80%BB%E8%BE%91%E6%80%9D%E7%BB%B4%2F</url>
      <content type="text"><![CDATA[写这个东西的原因 大学也即将毕业了，很多算法和数据结构的东西可能在iOS开发中并不能用得上，曾经有颗去BAT的心，错过了校招，希望厚积薄发，两三年后或许还有机会。记录下，那些大学里为之痴迷的东西。 什么是链表？ 对于计算机而言，大多数数据和信号的存储方式是离散的。那么今天要介绍的链表，就是一种离散结构的数据结构。与之对应的数组，是一种连续的数据结构。 先来看一张相对形象的图。 定义链表的节点 由于链表是由多个链表节点，连接而成。先看看如何定义一个节点吧，其实就是个结构体。 1234typedef struct Node &#123; int val; //数据域 struct Node *next; //指针域&#125;pNode; 一个节点中包含数据域和指针域，数据域用于存储节点的数据信息，而指针next则指向下一个节点的地址。从内存的角度来看，它便是离散的，因为指向的下一块内存不是连续的。 如何创建单链表 一条单链表中，必不可少的是头节点，相当于一个标记。个人习惯在头节点保存链表节点的个数 123456//creat a listinline Node *creat() &#123; Node *head = (Node *)malloc(sizeof(Node *)); head-&gt;next = NULL; //防止野指针 return head;&#125; 关于malloc（）,我们可以通过这个函数对头节点分配堆上的内存空间用于存储节点信息。而sizeof关键字就是计算需要分配多少的空间了。这个地方存在一个字节对齐的问题。感兴趣的同学可以深入理解。 链表的插入 头插法，效率高，也是C++ STL中使用的一种方式。 尾插法，效率低，只是介绍下，毕竟还是有区别的。 头插法 我们可以猜测，既然是头部插入，那我们插入的元素顺序就是逆序的。 12345678910//头插法，时间复杂度O(1)inline void push_front(Node *head, const int _val) &#123; if (!head) return ; //判断链表是否存在，通过头指针是否为空 Node *nNode = (Node *)malloc(sizeof(Node *)); nNode-&gt;val = _val; Node *pNode = head-&gt;next; nNode-&gt;next = pNode; head-&gt;next = nNode; ++head-&gt;val;//统计节点个数&#125; 尾插法 既然是尾部插入，那我们插入的元素顺序就是顺序的。 12345678910111213//尾插法，时间复杂度O(n) inline void push_back(Node *head, const int _val) &#123; if (!head) return ; Node *nNode = (Node *)malloc(sizeof(Node *)); nNode-&gt;val = _val; Node *pNode = head; while (pNode-&gt;next) &#123; pNode = pNode-&gt;next; &#125; pNode-&gt;next = nNode; nNode-&gt;next = NULL; ++head-&gt;val;//统计节点个数 &#125; 我们不难发现，之所以时间复杂度为O(n)，是因为，每次比头插法多花了一个while循环来遍历链表，直到找到链表的最后一个节点。 链表删除节点 任何一种数据结构，必不可少的都包含增删查改的功能。删除也是链表操作中较为复杂的一个操作。时间复杂度即为查找删除节点的遍历的复杂度。 12345678910111213141516171819//删除链表中第一个值为_val的节点inline void remove(Node *head, const int _val) &#123; if (!head || !head-&gt;next) return ; Node *pNode = head; while (pNode-&gt;next) &#123; if (pNode-&gt;next-&gt;val == _val) &#123; //找到要删除的元素 Node *dNode = pNode-&gt;next; pNode-&gt;next = dNode-&gt;next; if (!dNode-&gt;next) &#123; pNode-&gt;next = NULL; &#125; free(dNode); --head-&gt;val;//更新节点统计 break; &#125; pNode = pNode-&gt;next; &#125;&#125; 关于链表的一些巧妙应用 偷懒：至于什么判断链表是不是为空，链表节点个数，或者查找链表中某个元素是否存在的函数，我就懒得介绍了。接下来看几个有趣的应用。 如何判断单链表是否存在自环 这是前两年大公司非常喜欢问的一道题目，何谓自环？就是在链表中形成了一个循环。 对于这个问题，有一个很棒的思路， 那就是采用两个指针，一个指针从head开始，另一个从head-&gt;next开始，第一个指针每次只走一步，第二个指针每次走两步。正常不存在环的情况下，以第二个指针到达尾节点作为判断的依据，若是存在环，那必定这两个指针会相遇，那么指针相遇便能作为判断单链表中存在环的依据。 1234567891011//判断单链表中是否存在自环 1代表存在，0则反之。inline int judge_circle(Node *head) &#123; if (!head || !head-&gt;next) return 0; Node *first = head-&gt;next, *second = head-&gt;next-&gt;next; while (second &amp;&amp; first) &#123; if (first == second) return 1; second = second-&gt;next-&gt;next; first = first-&gt;next; &#125; return 0;&#125; 该算法的时间复杂度是O(n)的。也就是最多只会遍历一次链表。附上Leetcode题目地址：https://leetcode.com/problems/linked-list-cycle/ 翻转整条单链表 操作结果便是将 1-&gt;2-&gt;3-&gt;4-&gt;NULL 转换为 4-&gt;3-&gt;2-&gt;1-&gt;NULL. 思路很简单，无非就是指针操作，采用两个指针反复修改指向就可以了。Leetcode题目地址：https://leetcode.com/problems/reverse-linked-list/ 12345678910111213141516171819//翻转整条链表,时间复杂度为O(n)inline Node *reverse(Node *head) &#123; if (!head || !head-&gt;next) return head; Node *pNode = head, *qNode = pNode-&gt;next; pNode-&gt;next = NULL; if (!qNode-&gt;next) &#123; head = qNode; qNode-&gt;next = pNode; return head; &#125; while (qNode-&gt;next) &#123; head = qNode-&gt;next; qNode-&gt;next = pNode; pNode = qNode; qNode = head; &#125; head-&gt;next = pNode; return head;&#125; 总结：先记录这么多吧，还有些题目暂时还没时间去整理出来。接下来有时间会持续更新。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为什么我选择使用Blocks]]></title>
      <url>%2F2016%2F06%2F08%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8Blocks%2F</url>
      <content type="text"><![CDATA[扯淡：到了新公司接手新框架之后，发现大量的使用Blocks，之前很多时候都是使用代理，突然面对这个陌生的语法，特地科普总结了一番。 什么是Blocks 一句话概括就是，带有局部变量的匿名函数（即不带名称的函数）。也称为闭包。 Blocks语法 ^ 返回值类型 参数列表 表达式 12//例如^int (int count) &#123; return count + 1; &#125; 上述表达式中，返回值类型 以及 参数列表可以省略(如下), 语法加粗表明不可缺少的部分。 123^ &#123; printf("Hello, blocks");&#125; 将Blocks声明为属性 多数情况下，我们会把Blocks声明为属性，便于调用。可以利用关键字typedef 对Blocks进行别名。 12typedef 返回值类型 (^Blocks别名)(参数列表);typedef int (^blk_t)(int); 12//将Blocks声明为属性@property (nonatomic, copy) blk_t blk; 12//对Blocks进行声明定义blk = ^(int count) &#123; return count + 1; &#125;; 12//调用Blocks 和 调用C语言声明函数方式一样NSLog(@"%d\n", blk(10)); 将Blocks作为参数传入方法中 通常都会事先为Blocks取一个别名，一来方便理解，好吧不装逼，就是偷懒。 1234567//定义：typedef void(^Block)(int a);- (void)nslogParameterWithBlock:(Block)block &#123; if (block) &#123; block(10); &#125;&#125; 1234//赋值并调用[object nslogParameterWithBlock:^(int a) &#123; NSLog(@"%d", a);&#125;]; Blocks截获自动变量值 什么是截获自动变量值，所谓自动变量，就是局部变量。那为什么会截获呢？先来看个例子。 1234int val = 10;void (^block)(void) = ^ &#123; printf("val = %d", val); &#125;;val = 20;block(); //此处调用block，打印为val = 10； 之所以没有打印val = 20，是因为该Blocks在编译期就进行了初始化，对声明的val进行截获，也就是说，把val拷贝一份存入Blocks中。所以当外部val进行了修改时，不影响Blocks截获的val值。 __block 关键字 从上个例子中，我们知道Blocks会对变量进行截获。那如果我非要在Blocks中修改外部参数怎么办呢？我们可以通过__block关键字做到！ 1234__block int val = 10;void (^block)(void) = ^ &#123; printf("val = %d", val); &#125;;val = 20;block(); //此处调用block，打印为val = 20; 通过__block说明符对外部参数进行声明后，实际上，相当于在声明定义Blocks的时候，不是通过拷贝内存的方式拷贝外部参数，而是通过指针指向该外部变量，从而达到可以在Blocks中修改的效果。 总结： Blocks使用方便，但是block的内存管理确实是一项非常重要也非常容易出错的地方，稍不注意便会造成内存泄露，所以，在使用Blocks的时候，也要小心。 因为是匿名函数，所以在项目中多人合作的时候，最后写上每个Blocks的注释说明。 后续将继续总结Blocks的内存管理内容。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS UICollectionView瀑布流]]></title>
      <url>%2F2016%2F06%2F06%2FiOS-UICollectionView%E7%80%91%E5%B8%83%E6%B5%81%2F</url>
      <content type="text"><![CDATA[一、UICollectionViewLayout基础知识 如果要自定义UICollectionViewLayout，需要实现以下几个方法，按初始化layout后，系统执行顺序排列： 12// 初始化layout后自动调动，可以在该方法中初始化一些自定义的变量参数 - (void)prepareLayout; 12// 设置UICollectionView的内容大小，道理与UIScrollView的contentSize类似 - (CGSize)collectionViewContentSize; 12// 初始Layout外观，返回所有的布局属性 - (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect; 12// 根据不同的indexPath，给出布局 - (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath; 二、瀑布流布局 逻辑与原理 123456逻辑其实很简单，就是给出每一个cell的坐标。想要定位一个控件，需要CGRectMake四个参数：y : 首先我们看到的这个demo是两列的，所以肯定有两个Y轴起始点，分为左侧和右侧。x : 然后除Y轴不同外，左侧和右侧的X轴也不相同。width : 关于width我们可以通过一行两列，然后每一个cell的间距来得到。height: height是在collectionView中定义的，layout获得不到，所以我们选择用代理，在collectionView中设置。 需要的定义的变量 12345@property (assign, nonatomic) CGFloat leftY; // 左侧起始Y轴@property (assign, nonatomic) CGFloat rightY; // 右侧起始Y轴@property (assign, nonatomic) NSInteger cellCount; // cell个数@property (assign, nonatomic) CGFloat itemWidth; // cell宽度@property (assign, nonatomic) CGFloat insert; // 间距 代理的定义 1234567@class WaterfallFlowLayout;@protocol WaterfallFlowLayoutDelegate &lt;NSObject&gt;@required- (CGSize)collectionView:(UICollectionView *)collectionView collectionViewLayout:(sWaterfallFlowLayout *)collectionViewLayout sizeOfItemAtIndexPath:(NSIndexPath *)indexPath;@end 布局方法的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 初始化layout后自动调动，可以在该方法中初始化一些自定义的变量参数 */- (void)prepareLayout &#123; [super prepareLayout]; // 初始化参数 _cellCount = [self.collectionView numberOfItemsInSection:0]; // cell个数，直接从collectionView中获得 _insert = 10; // 设置间距 _itemWidth = (SCREEN_WIDTH - 3 * _insert) / 2; // cell宽度&#125;/** * 设置UICollectionView的内容大小，道理与UIScrollView的contentSize类似 * @return 返回设置的UICollectionView的内容大小 */- (CGSize)collectionViewContentSize &#123; return CGSizeMake(SCREEN_WIDTH, MAX(_leftY, _rightY));&#125;/** * 初始Layout外观 * @param rect 所有元素的布局属性 * @return 所有元素的布局 */- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect &#123; _leftY = _insert; // 左边起始Y轴 _rightY = _insert; // 右边起始Y轴 NSMutableArray *attributes = [[NSMutableArray alloc] init]; for (int i = 0; i &lt; self.cellCount; i ++) &#123; NSIndexPath *indexPath = [NSIndexPath indexPathForRow:i inSection:0]; [attributes addObject:[self layoutAttributesForItemAtIndexPath:indexPath]]; &#125; return attributes;&#125;/** * 根据不同的indexPath，给出布局 * @param indexPath * @return */- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath &#123; // 获取代理中返回的每一个cell的大小 CGSize itemSize = [self.delegate collectionView:self.collectionView collectionViewLayout:self sizeOfItemAtIndexPath:indexPath]; // 防止代理中给的size.width大于(或小于)layout中定义的width，所以等比例缩放size CGFloat itemHeight = floorf(itemSize.height * self.itemWidth / itemSize.width); UICollectionViewLayoutAttributes *attributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; // 判断当前的item应该在左侧还是右侧 BOOL isLeft = _leftY &lt; _rightY; if (isLeft) &#123; CGFloat x = _insert; attributes.frame = CGRectMake(x, _leftY, _itemWidth, itemHeight); _leftY += itemHeight + _insert; // 设置新的Y起点 &#125; else &#123; CGFloat x = _itemWidth + 2 * _insert; attributes.frame = CGRectMake(x, _rightY, _itemWidth, itemHeight); _rightY += itemHeight + _insert; &#125; return attributes;&#125; Demo地址https://github.com/shawenlx/WaterfallFlowCollection]]></content>
    </entry>

    
  
  
</search>
